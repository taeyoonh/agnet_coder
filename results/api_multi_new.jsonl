{"task_id": "bugfix_swebench_django_slugify", "engine": "api-multi", "timestamp": "2025-11-15T12:29:11.667993+00:00", "elapsed_sec": 179.473, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nNFKD/NFC 정규화 후 문자 단위로 안전하게 처리해 비ASCII 구분자는 하이픈으로 대체하고(단, 결합음(Combining) 문자는 구분자로 처리하지 않음), 연속 구분자와 앞뒤 하이픈을 제거하는 O(n) 슬러그화 구현.\n\n**핵심 검증 포인트**\n- allow_unicode=False일 때도 비-ASCII 구분자(예: em-dash)는 삭제하지 않고 하이픈으로 변환해 단어 경계가 붙지 않도록 한다.\n- 결합 음절/결합 부호(combining marks, Unicode category 'M')는 단어 경계를 만들지 않도록 특별 처리(ASCII 모드에서는 무시, 유니코드 모드에서는 가능한 경우 앞 문자에 붙여 보존).\n- 공백 및 밑줄은 하이픈으로, 기타 허용되지 않는 문자(ASCII 구두점 등)는 하이픈(구분자)으로 처리하되 연속 하이픈은 하나로 합친다.\n- 시간/공간 복잡도는 입력 길이 n에 대해 O(n)이고 추가 메모리는 결과 문자열 크기만큼만 사용한다.\n\n```python\nimport re\nimport unicodedata\nfrom typing import Optional\n\ndef solution(value: Optional[str], allow_unicode: bool = False) -> str:\n    \"\"\"\n    Create a URL slug from value.\n\n    - If allow_unicode is False: normalize NFKD, preserve ASCII letters/digits,\n      treat non-ASCII characters as possible separators but preserve boundaries\n      (i.e., replace by hyphen rather than deleting), and ignore combining marks.\n    - If allow_unicode is True: normalize NFC, preserve Unicode letters/numbers\n      (and combining marks attached to letters when present), other chars -> separator.\n    - Whitespace and underscores -> hyphen. Keep hyphens. Collapse multiple hyphens and trim edges.\n    \"\"\"\n    if value is None:\n        return \"\"\n\n    # Normalize according to mode\n    if allow_unicode:\n        s = unicodedata.normalize(\"NFC\", value)\n    else:\n        s = unicodedata.normalize(\"NFKD\", value)\n\n    s = s.lower()\n\n    def is_unicode_alnum(ch: str) -> bool:\n        # Unicode letter (L*) or number (N*)\n        cat = unicodedata.category(ch)\n        return bool(cat) and (cat[0] == \"L\" or cat[0] == \"N\")\n\n    def is_ascii_alnum(ch: str) -> bool:\n        return (\"a\" <= ch <= \"z\") or (\"0\" <= ch <= \"9\")\n\n    out = []\n    prev_was_hyphen = False\n\n    for ch in s:\n        # whitespace or underscore -> hyphen\n        if ch.isspace() or ch == \"_\":\n            if not prev_was_hyphen:\n                out.append(\"-\")\n                prev_was_hyphen = True\n            continue\n\n        # explicit hyphen keep (collapse via prev flag)\n        if ch == \"-\":\n            if not prev_was_hyphen:\n                out.append(\"-\")\n                prev_was_hyphen = True\n            continue\n\n        cat = unicodedata.category(ch)\n\n        # Combining marks: do not create separators.\n        # - In unicode-allowed mode, keep them attached if possible (append).\n        # - In ascii mode (after NFKD) skip them (they are accents on previous base).\n        if cat and cat[0] == \"M\":\n            if allow_unicode:\n                # Attach to previous char if exists and not hyphen; otherwise skip.\n                if out and not prev_was_hyphen:\n                    out.append(ch)\n                # if there's no previous base, skip the mark\n            # else: skip combining mark in ascii mode\n            continue\n\n        if allow_unicode:\n            # preserve unicode letters/numbers; others become separators\n            if is_unicode_alnum(ch):\n                out.append(ch)\n                prev_was_hyphen = False\n            else:\n                if not prev_was_hyphen:\n                    out.append(\"-\")\n                    prev_was_hyphen = True\n            continue\n\n        # ASCII mode (allow_unicode == False)\n        # If ASCII char -> decide directly\n        if ord(ch) < 128:\n            if is_ascii_alnum(ch):\n                out.append(ch)\n                prev_was_hyphen = False\n            else:\n                # ASCII punctuation/symbol -> separator\n                if not prev_was_hyphen:\n                    out.append(\"-\")\n                    prev_was_hyphen = True\n            continue\n\n        # Non-ASCII in ASCII mode: try to map to ASCII (e.g., decomposed base letters).\n        # If mapping yields ASCII letters/digits, append them; otherwise treat as separator.\n        mapped = ch.encode(\"ascii\", \"ignore\").decode(\"ascii\")\n        if mapped:\n            for c in mapped:\n                if is_ascii_alnum(c):\n                    out.append(c)\n                    prev_was_hyphen = False\n                else:\n                    if not prev_was_hyphen:\n                        out.append(\"-\")\n                        prev_was_hyphen = True\n            continue\n        else:\n            # Non-ASCII that maps to nothing (e.g., em-dash, CJK char): treat as separator\n            if not prev_was_hyphen:\n                out.append(\"-\")\n                prev_was_hyphen = True\n            continue\n\n    result = \"\".join(out)\n    # Collapse any remaining multiple hyphens and strip edges\n    result = re.sub(r\"-{2,}\", \"-\", result).strip(\"-\")\n    return result\n```\n\n테스트 가이드 (입력 / 기대 출력)\n- \"Hello World__Test\" / allow_unicode=False  -> \"hello-world-test\"\n- \"Déjà Vu!\" / allow_unicode=False  -> \"deja-vu\"\n- \"Déjà Vu!\" / allow_unicode=True   -> \"déjà-vu\"\n- \"a—b\" (em-dash) / allow_unicode=False -> \"a-b\"\n- \"안녕 세상__!\" / allow_unicode=True -> \"안녕-세상\"\n- \"안녕 세상__!\" / allow_unicode=False -> \"\"  (비ASCII들이 모두 제거되어 빈 문자열)\n- Edge: \"e\\u0301\" (e + combining acute) / allow_unicode=False -> \"e\" ; allow_unicode=True -> \"é\" (NFC로 합쳐질 때)\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "char_frequency_sort", "engine": "api-multi", "timestamp": "2025-11-15T12:30:58.467149+00:00", "elapsed_sec": 106.782, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/char_frequency_sort.py\", line 59, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/char_frequency_sort.py\", line 47, in main\n    raise AssertionError(\nAssertionError: s='tree', expected 'eetr', got 'eert'", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nO(n + k log k)에 동작하는 빈도 기반 정렬: 빈도 내림차순, 동률일 때는 유니코드 코드포인트(문자) 오름차순으로 반환합니다.\n\n**핵심 검증 포인트**\n- 문자 개수 총합(각 문자 빈도의 합)은 항상 입력 문자열 길이와 같아야 함(빈도 계산 불변).\n- 정렬 키는 (-빈도, 코드포인트)로 지정하여 빈도 우선 내림차순, 동률 시 문자 코드 오름차순을 보장해야 함.\n- 빈 문자열과 단일 문자/모든 문자가 동일한 경우 정상 처리, 그리고 Unicode(비 ASCII) 문자들에 대해서도 코드포인트 기반 정렬이 일관되게 동작해야 함.\n- 시간복잡도는 O(n + k log k) (n = 전체 문자수, k = 서로 다른 문자수), 추가 메모리는 O(k)여야 함.\n\n```python\nfrom collections import Counter\nfrom typing import List, Tuple\n\ndef solution(s: str) -> str:\n    \"\"\"\n    주어진 문자열 s의 문자를 빈도 내림차순으로 정렬하여 반환합니다.\n    같은 빈도인 문자는 유니코드 코드포인트(문자 자체의 비교 또는 ord)를 기준으로 오름차순 정렬합니다.\n    \"\"\"\n    if not s:\n        return \"\"\n\n    # 빈도 계산\n    counts = Counter(s)  # O(n) 시간, O(k) 메모리\n\n    # 정렬: 빈도 내림차순, 같은 빈도일 때 문자 코드포인트 오름차순\n    # ord(ch)을 명시적으로 사용해 코드포인트 기반 정렬을 분명히 함\n    # sorted의 키는 튜플이므로 우선순위가 올바르게 적용됩니다.\n    items: List[Tuple[str, int]] = sorted(counts.items(), key=lambda kv: (-kv[1], ord(kv[0])))\n\n    # 각 문자와 빈도수만큼 반복하여 합친다\n    return ''.join(ch * cnt for ch, cnt in items)\n\n\nif __name__ == \"__main__\":\n    # 기본 및 엣지 케이스 테스트\n    tests = [\n        (\"tree\", \"eert\"),        # e:2, r:1, t:1 -> e e r t\n        (\"\", \"\"),                # 빈 문자열\n        (\"aaaa\", \"aaaa\"),        # 모두 동일 문자\n        (\"bBaA\", \"ABab\"),        # 코드포인트 오름차순: 'A' < 'B' < 'a' < 'b'\n        (\"aabbcc\", \"aabbcc\"),    # 동률이면 문자 코드순\n        (\"ååßßa\", \"ßßååa\"),      # 'ß'(U+00DF) < 'å'(U+00E5)\n        # 큰 입력(간단한 성능/정합성 확인)\n        (\"a\"*1000 + \"b\"*999 + \"c\"*1000, \"a\"*1000 + \"c\"*1000 + \"b\"*999),\n    ]\n    for inp, exp in tests:\n        out = solution(inp)\n        assert out == exp, f\"입력: {inp!r}, 예상: {exp!r}, 실제: {out!r}\"\n    print(\"모든 테스트 통과\")\n```\n\n테스트 가이드\n- \"tree\" -> \"eert\" (e:2, r:1, t:1)\n- \"\" -> \"\" (빈 문자열)\n- \"aabbcc\" -> \"aabbcc\" (모든 빈도 동일, 문자 코드 오름차순)\n- \"ååßßa\" -> \"ßßååa\" (유니코드 코드포인트 비교 확인)\n- 대규모 입력 예: \"a\"*100000 + \"b\"*99999 (성능과 메모리 사용 확인)\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "num_islands", "engine": "api-multi", "timestamp": "2025-11-15T12:32:52.428159+00:00", "elapsed_sec": 113.943, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/num_islands.py\", line 61, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/num_islands.py\", line 53, in main\n    raise AssertionError(f\"grid={grid!r}, expected {expected}, got {result!r}\")\nAssertionError: grid=[['1', '1', '0', '0'], ['1', '0', '0', '1'], ['0', '0', '1', '1']], expected 3, got 2", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n입력을 변경하지 않고(행이 리스트든 문자열이든 안전하게) 방문 집합과 반복 DFS로 모든 4-연결 섬을 O(total_cells) 시간에 세는 구현입니다.\n\n**핵심 검증 포인트**\n- 입력 불변성: 함수는 grid를 in-place로 변경하지 않습니다(문자열 행이 들어와도 안전).\n- 인덱스 안전성: 각 이웃 접근 전에 해당 행의 길이를 체크하여 비직사각(행 길이 불균일) 그리드도 안전하게 처리합니다.\n- 반복/스택 사용: 재귀를 쓰지 않고 스택 기반 탐색을 사용해 깊이(재귀 한계) 문제를 회피합니다.\n- 복잡도: 모든 셀을 최대 한 번만 방문하므로 시간복잡도는 O(sum of row lengths)이고, 추가 공간은 방문 집합 및 스택으로 최악 O(sum of row lengths)입니다.\n\n```python\nfrom typing import List, Sequence, Tuple\n\ndef solution(grid: List[Sequence[str]]) -> int:\n    \"\"\"\n    Count number of islands (4-directionally connected '1' cells) in grid.\n    - Accepts grid as list of sequences (each row can be a list[str] or a str).\n    - Does NOT modify the input grid.\n    - Treats any cell equal to the character '1' as land; everything else is water.\n    \"\"\"\n    if not grid:\n        return 0\n\n    m = len(grid)\n    visited = set()  # set[tuple[int,int]]\n    islands = 0\n    dirs = ((1, 0), (-1, 0), (0, 1), (0, -1))\n\n    for r in range(m):\n        row = grid[r]\n        if not row:  # empty row: skip\n            continue\n        n_row = len(row)\n        for c in range(n_row):\n            if (r, c) in visited:\n                continue\n            # Only '1' (char) is considered land\n            try:\n                is_land = (row[c] == '1')\n            except Exception:\n                # If indexing fails for unexpected types, treat as water for safety\n                is_land = False\n            if not is_land:\n                continue\n\n            # Found new island; explore it (iterative DFS)\n            islands += 1\n            stack = [(r, c)]\n            visited.add((r, c))\n            while stack:\n                x, y = stack.pop()\n                for dx, dy in dirs:\n                    nx, ny = x + dx, y + dy\n                    if not (0 <= nx < m):\n                        continue\n                    # ensure ny is within bounds of that particular row\n                    if ny < 0:\n                        continue\n                    row_nx = grid[nx]\n                    if ny >= len(row_nx):\n                        continue\n                    if (nx, ny) in visited:\n                        continue\n                    # safe indexing: row_nx[ny] may raise, guard with try/except\n                    try:\n                        if row_nx[ny] != '1':\n                            continue\n                    except Exception:\n                        continue\n                    visited.add((nx, ny))\n                    stack.append((nx, ny))\n    return islands\n\n# 간단한 실행용 테스트 (직접 실행해 보세요)\nif __name__ == \"__main__\":\n    tests = [\n        ([], 0),                         # 빈 그리드\n        ([[]], 0),                       # 한 행이 빈 경우\n        ([['0']], 0),                    # 1x1 물\n        ([['1']], 1),                    # 1x1 땅\n        ([\"1\"], 1),                      # 행이 문자열인 경우 (문자열 불변성 확인)\n        ([\"101\"], 3),                    # 단일 문자열 행, 분리된 섬들\n        ([\"1\",\"0\",\"1\"], 2),              # 단일 열(문자열 행들)\n        ([['1','1','0','0','0'],\n          ['1','1','0','0','0'],\n          ['0','0','1','0','0'],\n          ['0','0','0','1','1']], 3),   # 여러 섬\n        ([['1','0','1','0','1']], 3),    # 가로로 나뉜 섬들\n        ([['1','1','1'], ['1','0','1'], ['1','1','1']], 1),  # 둘러싼 모양도 연결됨\n        ([\"10\",\"1\"], 1),                 # 비직사각: row lengths differ\n        ([\"0\"*1000 for _ in range(1000)], 0),  # 큰 모든 물 (성능/시간 확인)\n    ]\n\n    for idx, (g, expected) in enumerate(tests, 1):\n        res = solution(g)\n        print(f\"Test {idx}: result={res}, expected={expected}, pass={res==expected}\")\n```\n\n테스트 가이드\n- 빈 입력: []  → 0\n- 단일 문자열 행: [\"101\"]  → 3 (행이 문자열일 때 in-place 변경 에러 방지 확인)\n- 비직사각 예: [\"10\",\"1\"] → 1 (두 번째 행 길이 1인 경우 인덱스 체크)\n- 큰 전체 섬/전체 물: 1000x1000 모두 '1' (→ 1) 또는 모두 '0' (→ 0)로 성능/메모리 확인\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "max_subarray_sum", "engine": "api-multi", "timestamp": "2025-11-15T12:34:13.996624+00:00", "elapsed_sec": 81.554, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nO(n) Kadane 알고리즘으로 구현하되 입력 타입을 엄격히 검사하여 안전성을 강화한 버전입니다.\n\n**핵심 검증 포인트**\n- 입력 불변: nums는 길이 >= 1인 list여야 하며, 모든 원소는 정수(int)여야 한다(형식 검사 포함).\n- 결과 불변: 모든 음수인 경우에도 가장 큰 원소(가장 덜 음수)를 반환해야 한다.\n- 인덱스/루프: 배열의 첫 요소로 초기화하고 그 이후 요소들만 순회하여 인덱스 범위 오류가 발생하지 않음.\n- 시간/공간 복잡도: 단일 순회 O(n), 추가 공간 O(1).\n\n```python\ndef solution(nums: list[int]) -> int:\n    \"\"\"\n    주어진 정수 리스트 nums에서 연속 부분 배열(subarray)의 최대 합을 반환한다.\n    요구된 시그니처를 엄격히 따르며 입력 검사를 수행한다.\n    시간복잡도: O(n), 추가공간: O(1)\n    \"\"\"\n    # 입력 타입/길이 검사 (요구사항: 정확히 list[int])\n    if not isinstance(nums, list):\n        raise TypeError(\"nums must be a list[int]\")\n    if len(nums) == 0:\n        raise ValueError(\"nums must contain at least one element\")\n\n    # 첫 원소 검사 및 초기화\n    first = nums[0]\n    if type(first) is not int:\n        raise TypeError(\"all elements of nums must be int\")\n    max_ending = max_so_far = first\n\n    # Kadane 알고리즘: 각 위치에서 끝나는 최대 연속합을 갱신\n    for x in nums[1:]:\n        if type(x) is not int:\n            raise TypeError(\"all elements of nums must be int\")\n        # 현재 원소로 새로 시작하거나 기존 구간을 확장하는 것 중 최댓값\n        max_ending = max(x, max_ending + x)\n        if max_ending > max_so_far:\n            max_so_far = max_ending\n\n    return max_so_far\n\n\nif __name__ == \"__main__\":\n    # 기본/엣지 케이스 검증\n    assert solution([1, -2, 3, 5, -1, 2]) == 9\n    assert solution([-3, -1, -4]) == -1\n    assert solution([5]) == 5\n    assert solution([0, -1, 0, -2, 0]) == 0\n\n    # 추가 테스트\n    assert solution([-5, -1, -8, -2]) == -1\n    assert solution([2, -1, 2, 3, -9]) == 6\n    assert solution([1, -3, 2, 1, -1]) == 3\n    assert solution([0, 0, 0]) == 0\n\n    print(\"All tests passed.\")\n```\n\n테스트 가이드\n- [기본 혼합] 입력: [1, -2, 3, 5, -1, 2] / 기대값: 9\n- [모두 음수] 입력: [-5, -1, -8, -2] / 기대값: -1\n- [단일 원소] 입력: [5] / 기대값: 5\n- [제로 패턴] 입력: [0, 0, 0, -1, 0] / 기대값: 0\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "min_cost_path_grid", "engine": "api-multi", "timestamp": "2025-11-15T12:35:57.589924+00:00", "elapsed_sec": 103.576, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nO(m*n) 시간, O(n) 추가 공간의 정수 기반 1차원 DP로 최소 비용 경로를 계산합니다.\n\n**핵심 검증 포인트**\n- grid는 직사각형(모든 행의 길이가 동일)이어야 하며, 빈 입력([] 또는 [[]])은 비용 0으로 처리하되 \"부분적으로 빈\" (예: [[], [1]]) 입력은 예외로 처리합니다.\n- 인덱스 접근 불변: dp 배열 길이 = 열 수 n, 모든 루프에서 j는 0..n-1 범위 내로만 접근합니다.\n- 정수 연산 불변: 모든 누적 계산은 Python의 임의정밀 정수(int)만 사용하여 정밀도 손실 위험 제거.\n- 성능 불변: 시간 복잡도 O(m*n), 추가 공간 O(n) — m 행, n 열에 대해 각 칸을 한 번만 처리.\n\n```python\nfrom typing import List\n\ndef solution(grid: List[List[int]]) -> int:\n    \"\"\"\n    각 칸의 비용이 주어진 grid에서 (0,0)에서 (m-1,n-1)까지\n    오른쪽 또는 아래로만 이동하여 방문한 칸들의 비용 합의 최소값을 반환한다.\n\n    - 빈 그리드([]) 또는 열이 0인 그리드([[], [], ...] 또는 [[]])는 비용 0으로 간주한다.\n    - 모든 행의 길이는 같아야 하며(직사각형), 그렇지 않으면 ValueError를 발생시킨다.\n    - 각 비용은 0 이상의 정수여야 하며, 음수나 비정수 값이 있으면 ValueError를 발생시킨다.\n\n    시간 복잡도: O(m * n), 추가 공간: O(n) (n = 열 수)\n    \"\"\"\n    # 빠른 빈 입력 처리\n    if not grid:\n        return 0\n\n    n = len(grid[0])\n\n    # 모든 행이 같은 길이인지 검사하고, 요소들이 정수(>=0)인지 검사\n    for idx, row in enumerate(grid):\n        if len(row) != n:\n            raise ValueError(f\"grid must be rectangular: row 0 has length {n}, but row {idx} has length {len(row)}\")\n        # If there are zero columns (n == 0), skip element checks; will return 0 below.\n        if n > 0:\n            for j, v in enumerate(row):\n                if not isinstance(v, int):\n                    raise ValueError(f\"grid[{idx}][{j}] must be an int, got {type(v).__name__}\")\n                if v < 0:\n                    raise ValueError(f\"grid[{idx}][{j}] must be >= 0, got {v}\")\n\n    # If there are zero columns, treat as zero-cost (e.g., [[]] or [[], [], ...])\n    if n == 0:\n        return 0\n\n    m = len(grid)\n\n    # dp[j] := 현재 처리 중인 행 i에서 (i, j)까지의 최소 누적 비용\n    dp: List[int] = [0] * n\n\n    # 첫 행 초기화 (정수 연산만 사용)\n    dp[0] = grid[0][0]\n    for j in range(1, n):\n        dp[j] = dp[j - 1] + grid[0][j]\n\n    # 나머지 행들 처리\n    for i in range(1, m):\n        # 첫 열은 위에서만 올 수 있음\n        dp[0] += grid[i][0]\n        for j in range(1, n):\n            # 왼쪽(dp[j-1]) 혹은 위(dp[j])에서 오는 값 중 작은 쪽 선택\n            dp[j] = min(dp[j - 1], dp[j]) + grid[i][j]\n\n    return dp[-1]\n\n\nif __name__ == \"__main__\":\n    # 기본 케이스\n    assert solution([[5]]) == 5\n    assert solution([[1, 2, 3]]) == 6\n    assert solution([[1], [2], [3]]) == 6\n    assert solution([[1, 3, 1], [1, 5, 1], [4, 2, 1]]) == 7\n    assert solution([[0, 0, 0], [0, 0, 0]]) == 0\n    # 빈 입력\n    assert solution([]) == 0\n    assert solution([[]]) == 0\n    assert solution([[], [], []]) == 0\n\n    # 추가 검증\n    assert solution([[1, 2], [3, 4]]) == 7  # right -> down\n    assert solution([[0, 10**18], [0, 0]]) == 0  # 큰 값 포함되어도 정수 정확성 유지\n    assert solution([[1,1,1],[1,1,1],[1,1,1]]) == 5\n\n    # 비정형(직사각형 아님) 입력은 예외 발생\n    try:\n        solution([[1, 2], [3]])\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Expected ValueError for non-rectangular grid\")\n\n    print(\"All tests passed.\")\n```\n\n테스트 가이드\n- 최소 입력: []  -> 기대 출력 0\n- 1x1: [[5]] -> 5\n- single row: [[1,2,3]] -> 6\n- single column: [[1],[2],[3]] -> 6\n- 일반: [[1,3,1],[1,5,1],[4,2,1]] -> 7\n- 큰 값 포함: [[0,10**18],[0,0]] -> 0 (정수 연산 확인)\n- 비정형(예외): [[1,2],[3]] -> ValueError\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "job_scheduling_max_profit", "engine": "api-multi", "timestamp": "2025-11-15T12:37:49.958718+00:00", "elapsed_sec": 112.351, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/job_scheduling_max_profit.py\", line 45, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/job_scheduling_max_profit.py\", line 36, in main\n    raise AssertionError(\nAssertionError: starts=[1, 2, 3, 4], ends=[3, 5, 10, 6], profits=[20, 20, 100, 70], expected 150, got 120", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n종료 시간 정렬 + 이분탐색(bisect_right) 기반의 DP (dp[i]는 처음 i개 작업 고려 시 최대 이익)로 O(n log n)에 풀이.\n\n**핵심 검증 포인트**\n- 불변 조건: 선택된 작업들은 [start, end) 기준으로 겹치지 않아야 하며, end_i <= start_j 이면 non-overlap으로 판단한다.\n- 정렬/인덱스 불변성: jobs를 (end, start) 기준으로 정렬했을 때 ends_sorted는 비감소 순서이며, bisect_right(ends_sorted, start_i)는 종료 시간이 start_i 이하인 작업의 개수를 반환(즉 dp 인덱스 j)해야 한다.\n- DP 전이 불변성: dp는 길이 n+1이며 dp[0]=0, 일반 전이는 dp[i] = max(dp[i-1], profit_i + dp[j])로 항상 정의된다.\n- 엣지 케이스: 빈 입력, 0-길이 작업(start==end), 같은 종료시간을 가지는 다수 작업 등에서 인덱스/경계 처리가 안전해야 한다.\n\n```python\nfrom bisect import bisect_right\nfrom typing import List, Tuple\nimport random\nimport itertools\n\ndef solution(starts: List[int], ends: List[int], profits: List[int]) -> int:\n    \"\"\"\n    Weighted interval scheduling (jobs are [start, end), non-overlap if end_i <= start_j).\n    Returns the maximum total profit choosing non-overlapping jobs.\n    Time: O(n log n), Space: O(n)\n    \"\"\"\n    if not (len(starts) == len(ends) == len(profits)):\n        raise ValueError(\"Input lists must have the same length.\")\n    n = len(starts)\n    if n == 0:\n        return 0\n\n    # Build jobs and sort by end time (then start for determinism)\n    jobs: List[Tuple[int, int, int]] = sorted(zip(starts, ends, profits), key=lambda x: (x[1], x[0]))\n    ends_sorted: List[int] = [job[1] for job in jobs]\n\n    # dp[i]: max profit considering first i jobs (jobs[0..i-1])\n    dp: List[int] = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n        start_i, end_i, profit_i = jobs[i - 1]\n        # count of jobs with end <= start_i\n        j = bisect_right(ends_sorted, start_i)\n        take = profit_i + dp[j]\n        not_take = dp[i - 1]\n        dp[i] = max(not_take, take)\n\n    return dp[n]\n\n\n# --- 자체 간단 검증 ---\nif __name__ == \"__main__\":\n    # 기본 예제들\n    assert solution([1,3,6], [2,5,9], [50,20,100]) == 170\n    assert solution([1,2,4], [3,5,6], [50,200,100]) == 200\n    assert solution([1,3], [3,5], [10,20]) == 30\n    assert solution([], [], []) == 0\n\n    # 동일한 종료시간, 0-length job 포함\n    assert solution([1,2,2], [5,5,5], [10,100,90]) == 100\n    assert solution([1,1,2], [1,2,3], [10,20,30]) == 60\n\n    # 추가: brute-force로 작은 무작위 케이스 비교 검증\n    def brute_force_max_profit(starts, ends, profits):\n        n = len(starts)\n        best = 0\n        for mask in range(1 << n):\n            ok = True\n            total = 0\n            chosen = []\n            for i in range(n):\n                if mask & (1 << i):\n                    chosen.append(i)\n                    total += profits[i]\n            # check non-overlap among chosen\n            for a, b in itertools.combinations(chosen, 2):\n                sa, ea = starts[a], ends[a]\n                sb, eb = starts[b], ends[b]\n                # overlap if intervals intersect in [start, end)\n                if not (ea <= sb or eb <= sa):\n                    ok = False\n                    break\n            if ok and total > best:\n                best = total\n        return best\n\n    # run a few random tests\n    for _ in range(50):\n        n = random.randint(0, 7)\n        starts = [random.randint(0, 5) for _ in range(n)]\n        ends = [s + random.randint(0, 5) for s in starts]\n        profits = [random.randint(0, 20) for _ in range(n)]\n        assert solution(starts, ends, profits) == brute_force_max_profit(starts, ends, profits)\n\n    print(\"All self-tests passed.\")\n```\n\n테스트 가이드\n- 작은 비겹침 전부 선택 가능: starts=[1,3,6], ends=[2,5,9], profits=[50,20,100] -> 170\n- 겹침 발생: starts=[1,2,4], ends=[3,5,6], profits=[50,200,100] -> 200\n- 경계 비충돌 확인: starts=[1,3], ends=[3,5], profits=[10,20] -> 30\n- 동일 종료시간 및 0-길이 작업: starts=[1,2,2], ends=[5,5,5], profits=[10,100,90] -> 100\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "regex_match_dot_star", "engine": "api-multi", "timestamp": "2025-11-15T12:41:09.741676+00:00", "elapsed_sec": 199.766, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n동적 계획법(bottom-up)으로 구현한 정규표현식 유사 매칭 ('.'는 임의의 문자, '*'는 바로 앞 요소의 0회 이상 반복), 입력 패턴이 문법적으로 명백히 잘못된 경우(False 반환)로 처리하는 보수적 정책 적용.\n\n**핵심 검증 포인트**\n- '*'는 항상 바로 앞에 적용될 요소가 있어야 한다(invariant: p에서 '*'가 첫 문자이면 잘못된 패턴). 또한 연속되는 '*'는 문법적으로 모호하므로 잘못된 패턴으로 간주한다(안전한 정책).\n- dp 테이블 크기와 인덱스: dp는 (m+1)x(n+1)이고 dp[i][j]는 s[i:]와 p[j:]의 매칭 여부다. i와 j 접근은 항상 범위 검사(i < m, j+1 < n)를 통해 안전하게 이뤄져야 한다.\n- 점화식 불변: first_match = (i < m) and (p[j] == s[i] or p[j] == '.')이며, 다음이 '*'일 때는 0회(dp[i][j+2]) 또는 1회 이상(first_match and dp[i+1][j])의 두 선택을 정확히 적용해야 한다.\n- 엣지 케이스 검증: 빈 문자열과 패턴, 패턴 끝의 '*' 유무, 잘못된 패턴(\"*\", \"*a\", \"a**\" 등)에 대한 동작을 명확히 정의(본 구현은 잘못된 패턴에 대해 False 반환).\n\n```python\nfrom typing import List\n\ndef solution(s: str, p: str) -> bool:\n    \"\"\"\n    s: 입력 문자열\n    p: 패턴 ('.'는 임의의 한 문자, '*'는 바로 앞 문자(또는 '.')의 0회 이상 반복)\n    반환: s 전체가 p 전체와 정확히 매칭되면 True, 아니면 False\n\n    보수적 정책: 패턴이 문법적으로 명백히 잘못된 경우(예: '*'가 패턴의 첫 문자이거나 연속되는 '*')\n   에는 False를 반환하여 입력 오류를 드러낸다.\n    \"\"\"\n\n    # 검증: '*'가 첫 문자이거나 연속으로 등장하면 잘못된 패턴으로 처리\n    for idx, ch in enumerate(p):\n        if ch == '*':\n            if idx == 0:\n                # 선행 요소 없이 '*' 등장 -> 잘못된 패턴으로 간주\n                return False\n            if p[idx - 1] == '*':\n                # 연속된 '*' -> 모호/잘못된 패턴으로 간주\n                return False\n\n    m, n = len(s), len(p)\n\n    # dp[i][j] : s[i:] matches p[j:]\n    dp: List[List[bool]] = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[m][n] = True  # 빈 문자열과 빈 패턴은 매칭\n\n    # bottom-up으로 채우기: i from m down to 0, j from n-1 down to 0\n    for i in range(m, -1, -1):\n        for j in range(n - 1, -1, -1):\n            first_match = (i < m) and (p[j] == s[i] or p[j] == '.')\n            # '*'가 다음 위치에 있는지 확인\n            if j + 1 < n and p[j + 1] == '*':\n                # 0번 반복 (skip p[j] and '*') 또는 1번 이상 반복(현재 문자 매칭되고 이후도 매칭)\n                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])\n            else:\n                dp[i][j] = first_match and dp[i + 1][j + 1]\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    # 대표적인 테스트들 (패턴 문법 오류는 False를 기대)\n    tests = [\n        (\"aa\", \"a\", False),\n        (\"aa\", \"a*\", True),\n        (\"ab\", \".*\", True),\n        (\"aab\", \"c*a*b\", True),\n        (\"mississippi\", \"mis*is*p*.\", False),\n        (\"\", \"a*\", True),       # 빈 문자열은 'a*'와 매칭(0회)\n        (\"\", \".*\", True),\n        (\"\", \"\", True),\n        (\"ab\", \".*c\", False),\n        # 잘못된 패턴(보수적 처리 -> False)\n        (\"a\", \"a**\", False),    # 연속 '*'이므로 잘못된 패턴으로 간주\n        (\"\", \"*a\", False),      # 선행 요소 없는 '*' -> 잘못된 패턴으로 간주\n        (\"\", \"*\", False),       # 잘못된 패턴\n    ]\n    for s, p, expected in tests:\n        res = solution(s, p)\n        assert res == expected, f\"Failed: s={s!r}, p={p!r}, got={res}, expected={expected}\"\n    print(\"All tests passed.\")\n```\n\n테스트 가이드\n- 기본: (\"aa\", \"a\") → False, (\"aa\", \"a*\") → True\n- 점(.) 및 별(*) 조합: (\"ab\", \".*\") → True, (\"abc\", \".*c\") → True\n- 빈 문자열/패턴: (\"\", \"a*\") → True, (\"\", \"\") → True\n- 잘못된 패턴(보수적 처리): (\"a\", \"a**\") → False, (\"\", \"*\") → False\n\n(설계 메모) 본 구현은 패턴 문법 오류를 명시적으로 False로 처리하는 보수적 정책을 채택했습니다. 만약 사용자 요구가 '관대한' 해석(중복 '*'를 병합하거나 선행 '*'를 무시)이라면 normalize 단계로 패턴을 전처리한 뒤 매칭하는 방식으로 쉽게 변경할 수 있습니다.\n\n<END-OF-CODE>", "code_block_present": true}

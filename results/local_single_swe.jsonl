{"task_id": "changelog_parser_structured", "engine": "local-single", "timestamp": "2025-11-16T07:24:04.778286+00:00", "elapsed_sec": 3.724, "success": false, "error": "no code block found in response", "checker_output": "", "headline": "AI 코드 플랜", "response_body": "```python\nimport re\nfrom typing import Optional\n\ndef solution(changelog: str) -> dict[str, object]:\n    def parse_date(header: str) -> Optional[str]:\n        match = re.search(r'\\d{4}-\\d{2}-\\d{2}', header)\n        return match.group(0) if match else None\n\n    def parse_header(header: str) -> tuple[str, Optional[str]]:\n        label = re.match(r'## \\[(.*?)\\] - .*', header).group(1)\n        date = parse_date(header)\n        return label, date\n\n    def parse_section(section: str) -> tuple[str, list[str]]:\n        items = re.findall(r'- (.*?)\\n', section)\n        cleaned_items = [item.strip() for item in items]\n        cleaned_items = [item for item in cleaned_items if item]\n        return section.split('\\n')[0].split(' ')[1], cleaned_items\n\n    entries = []\n    current_entry = None\n    unreleased = False\n\n    for line in changelog.splitlines():\n        if re.match(r'## \\[Unreleased\\]', line):\n            unreleased = True\n        elif re.match(r'## \\[.*?\\] - .*', line):\n            if current_entry:\n                entries.append(current_entry)\n            label, date = parse_header(line)\n            current_entry = {\n                \"label\": label,\n                \"date\": date,\n                \"sections\": {}\n            }\n        elif re.match(r'### .*', line):\n            section_label, items = parse_section(line)\n            if items:\n                current_entry[\"sections\"][section_label] = items\n\n    if current_entry:\n        entries.append(current_entry)\n\n    if unreleased:\n        latest_release = entries[-1]\n    else:\n        latest_release = entries[-2]\n\n    return {\n        \"entries\": entries,\n        \"latest_release\": latest_release\n    }", "code_block_present": false}
{"task_id": "service_health_dashboard", "engine": "local-single", "timestamp": "2025-11-16T07:24:12.189424+00:00", "elapsed_sec": 7.411, "success": false, "error": "no code block found in response", "checker_output": "", "headline": "AI 코드 플랜", "response_body": "```python\ndef solution(snapshots: list[dict[str, object]], *, latency_budget: int = 140, error_budget: float = 1.0, deploy_recency: int = 180) -> dict[str, object]:\n    # 1. 초기화\n    services_summary = {}\n    total_regions = 0\n    \n    # 2. 스냅샷 데이터를 순회하며 요약 정보 생성\n    for snapshot in snapshots:\n        service = snapshot['service']\n        region = snapshot['region']\n        latency_ms_p95 = snapshot['latency_ms_p95']\n        error_rate = snapshot['error_rate']\n        uptime = snapshot['uptime']\n        alerts = snapshot['alerts']\n        deploy_offset_min = snapshot['deploy_offset_min']\n        \n        # 서비스 초기화\n        if service not in services_summary:\n            services_summary[service] = {\n                'status': 'HEALTHY',\n                'regions': {},\n                'action_items': set()\n            }\n        \n        # 지역 초기화\n        if region not in services_summary[service]['regions']:\n            services_summary[service]['regions'][region] = {\n                'status': 'HEALTHY',\n                'latency_ms_p95': latency_ms_p95,\n                'error_rate': error_rate,\n                'uptime': uptime,\n                'alerts': alerts\n            }\n        \n        # 지역 상태 결정\n        region_status = 'HEALTHY'\n        if 'outage' in alerts or uptime < 0.92:\n            region_status = 'DOWN'\n        elif latency_ms_p95 > latency_budget or error_rate > error_budget:\n            region_status = 'DEGRADED'\n        elif deploy_offset_min > deploy_recency:\n            region_status = 'DEGRADED'\n        \n        # 지역 상태 업데이트\n        services_summary[service]['regions'][region]['status'] = region_status\n        \n        # 액션 아이템 생성\n        action_items = []\n        if latency_ms_p95 > latency_budget:\n            action_items.append(f\"latency p95 {latency_ms_p95}ms exceeds {latency_budget}ms budget\")\n        if error_rate > error_budget:\n            action_items.append(f\"error rate {error_rate:.2f}% exceeds {error_budget:.2f}% budget\")\n        if deploy_offset_min > deploy_recency:\n            action_items.append(f\"deploy overdue by {deploy_offset_min} minutes\")\n        if 'outage' in alerts:\n            action_items.append(\"outage declared via alerts\")\n        if len(alerts) > 0:\n            action_items.append(f\"outstanding alerts {', '.join(alerts)}\")\n        \n        # 액션 아이템 추가\n        for action in action_items:\n            services_summary[service]['action_items'].add(f\"{service}/{region}: {action}\")\n        \n        # 총 지역 수 계산\n        total_regions += 1\n    \n    # 3. 전체 서비스 상태 결정\n    global_status = 'HEALTHY'\n    for service in services_summary:\n        service_status = services_summary[service]['status']\n        if service_status == 'DOWN':\n            global_status = 'DOWN'\n            break\n        elif service_status == 'DEGRADED':\n            global_status = 'DEGRADED'\n    \n    # 4. 최종 출력 딕셔너리 생성\n    result = {\n        'services': services_summary,\n        'total_regions': total_regions,\n        'global_status': global_status\n    }\n    \n    return result", "code_block_present": false}
{"task_id": "config_patch_engine", "engine": "local-single", "timestamp": "2025-11-16T07:24:25.580676+00:00", "elapsed_sec": 13.391, "success": false, "error": "no code block found in response", "checker_output": "", "headline": "운영 환경 설정에 패치 오퍼레이션 적용하는 엔진 작성", "response_body": "### 운영 환경 설정에 패치 오퍼레이션 적용하는 엔진 작성\n\n**문제 분석**\n- `operations`는 `op` (`\"set\"`, `\"merge\"`, `\"remove\"`), `path`, `value`(remove 제외) 키를 가진 딕셔너리입니다.\n- `path`는 점(`.`)으로 구분된 키와 선택적으로 리스트 인덱스 표현(`[i]`)을 포함합니다.\n- `set`: 지정된 경로에 값을 할당합니다. 존재하지 않는 중간 딕셔너리는 자동으로 생성합니다.\n- `merge`: 경로가 가리키는 값과 `value`(dict)를 재귀적으로 병합합니다.\n- `remove`: 경로가 dict 키면 키를 삭제, 리스트 인덱스면 해당 요소를 제거하고 뒤 요소를 앞으로 당깁니다.\n- 함수는 원본 `base_config`를 변경하지 말고, 패치 결과를 담은 새 dict를 반환해야 합니다.\n\n**실행 계획**\n1. `base_config`를 복사하여 새로운 딕셔너리를 생성합니다.\n2. `operations` 리스트를 순회하며 각 연산을 처리합니다.\n3. `set` 연산: `path`를 분해하여 중간 딕셔너리를 생성하고 값을 할당합니다.\n4. `merge` 연산: `path`를 분해하여 중간 딕셔너리를 찾고, `value`를 재귀적으로 병합합니다.\n5. `remove` 연산: `path`를 분해하여 중간 딕셔너리를 찾고, 해당 키 또는 인덱스를 삭제합니다.\n6. 최종적으로 수정된 딕셔너리를 반환합니다.\n\n**핵심 코드**\n```python\ndef solution(base_config: dict[str, object], operations: list[dict[str, object]]) -> dict[str, object]:\n    def get_value(config, path):\n        keys = path.split('.')\n        for key in keys:\n            if isinstance(config, list):\n                index = int(key.strip('[]'))\n                if index >= len(config):\n                    raise IndexError\n                config = config[index]\n            elif isinstance(config, dict):\n                config = config.get(key)\n                if config is None:\n                    raise KeyError\n            else:\n                raise TypeError\n        return config\n\n    def set_value(config, path, value):\n        keys = path.split('.')\n        for i, key in enumerate(keys[:-1]):\n            if isinstance(config, list):\n                index = int(key.strip('[]'))\n                if index >= len(config):\n                    raise IndexError\n                if i == len(keys) - 2:\n                    if isinstance(config[index], list):\n                        config[index].append(value)\n                    else:\n                        config[index] = value\n                else:\n                    config = config[index]\n            elif isinstance(config, dict):\n                if key not in config:\n                    config[key] = {}\n                config = config[key]\n            else:\n                raise TypeError\n        last_key = keys[-1]\n        if isinstance(config, list):\n            index = int(last_key.strip('[]'))\n            if index >= len(config):\n                raise IndexError\n            config[index] = value\n        elif isinstance(config, dict):\n            config[last_key] = value\n        else:\n            raise TypeError\n        return config\n\n    def merge_value(config, path, value):\n        keys = path.split('.')\n        for i, key in enumerate(keys[:-1]):\n            if isinstance(config, list):\n                index = int(key.strip('[]'))\n                if index >= len(config):\n                    raise IndexError\n                config = config[index]\n            elif isinstance(config, dict):\n                if key not in config:\n                    config[key] = {}\n                config = config[key]\n            else:\n                raise TypeError\n        last_key = keys[-1]\n        if isinstance(config, list):\n            index = int(last_key.strip('[]'))\n            if index >= len(config):\n                raise IndexError\n            if isinstance(value, dict) and isinstance(config[index], dict):\n                config[index].update(value)\n            else:\n                raise TypeError\n        elif isinstance(config, dict):\n            if isinstance(value, dict) and isinstance(config.get(last_key), dict):\n                config[last_key].update(value)\n            else:\n                raise TypeError\n        else:\n            raise TypeError\n        return config\n\n    def remove_value(config, path):\n        keys = path.split('.')\n        for i, key in enumerate(keys[:-1]):\n            if isinstance(config, list):\n                index = int(key.strip('[]'))\n                if index >= len(config):\n                    raise IndexError\n                config = config[index]\n            elif isinstance(config, dict):\n                if key not in config:\n                    raise KeyError\n                config = config[key]\n            else:\n                raise TypeError\n        last_key = keys[-1]\n        if isinstance(config, list):\n            index = int(last_key.strip('[]'))\n            if index >= len(config):\n                raise IndexError\n            del config[index]\n            for i in range(index, len(config)):\n                config[i - 1] = config[i]\n            del config[-1]\n        elif isinstance(config, dict):\n            if last_key not in config:\n                raise KeyError\n            del config[last_key]\n        else:\n            raise TypeError\n        return config\n\n    result_config = base_config.copy()\n    for operation in operations:\n        op = operation['op']\n        path = operation['path']\n        value = operation.get('value')\n        if op == 'set':\n            result_config = set_value(result_config, path, value)\n        elif op == 'merge':\n            result_config = merge_value(result_config, path, value)\n        elif op == 'remove':\n            result_config = remove_value(result_config, path)\n    return result_config", "code_block_present": false}

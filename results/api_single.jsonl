{"task_id": "two_sum_indices", "engine": "api-single", "timestamp": "2025-11-15T11:08:02.637054+00:00", "elapsed_sec": 26.326, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\ni를 작은 순서로, 같은 i에선 j를 작은 순서로 검사해 최초 발견되는 (i, j)를 반환하는 간단하고 안전한 O(n^2) 해법입니다.\n\n**문제 분석**\n- 반환은 0-기반 인덱스의 튜플 (i, j), 항상 i < j여야 하며 여러 해 중 사전식(lexicographic)으로 가장 앞서는 것을 선택합니다.\n- 입력 길이 최대 2000으로 O(n^2) 탐색이 허용되므로 단순한 이중 반복으로도 충분합니다.\n- 해가 없으면 ValueError를 발생시켜야 합니다.\n- 표준 라이브러리만 사용합니다.\n\n**실행 계획**\n1. 입력 길이가 최소 2인지 확인(안정성 검사).\n2. i를 0부터 증가시키며, 각 i에 대해 j = i+1..n-1를 증가시키며 nums[i] + nums[j] == target인지 검사한다.\n3. 조건 만족 시 즉시 (i, j)를 반환한다(이 방식으로 사전식 최소 보장).\n4. 모든 쌍을 검사해도 없으면 ValueError를 발생시킨다.\n\n**핵심 코드**\n```python\nfrom typing import List, Tuple\n\ndef solution(nums: List[int], target: int) -> Tuple[int, int]:\n    \"\"\"\n    Returns the lexicographically smallest pair of indices (i, j) with i < j such that\n    nums[i] + nums[j] == target. Raises ValueError if no such pair exists.\n    \"\"\"\n    n = len(nums)\n    if n < 2:\n        raise ValueError(\"Input must contain at least two numbers.\")\n    # Scan i increasing; for each i scan j increasing -> first found is lexicographically smallest\n    for i in range(n - 1):\n        ai = nums[i]\n        # inner loop from i+1 to end, j increasing ensures smallest j for current i\n        for j in range(i + 1, n):\n            if ai + nums[j] == target:\n                return (i, j)\n    raise ValueError(\"No two indices sum to the target.\")\n\n# 간단한 자기검증 테스트 (모듈로 사용될 때 실행되지 않도록 보호)\nif __name__ == \"__main__\":\n    # 대표적인 예\n    assert solution([2, 7, 11, 15], 9) == (0, 1)\n    # 여러 해가 있는 경우: (0,3)과 (1,2) 둘 다 가능하면 (0,3) 선택 (i 우선)\n    assert solution([1, 2, 3, 4], 5) == (0, 3)\n    # 같은 값 여러 개: 두 인덱스 다 다른 경우 선택\n    assert solution([3, 3, 4], 6) == (0, 1)\n    # 음수 포함\n    assert solution([-1, 2, 3, -2], 1) == (0, 2)\n    try:\n        solution([1, 2], 10)\n    except ValueError:\n        pass\n    else:\n        raise AssertionError(\"Expected ValueError for no solution\")\n    print(\"All internal tests passed.\")\n```\n\n**테스트 가이드**\n- 기본 케이스: nums=[2,7,11,15], target=9 -> (0,1)\n- 다중 해 케이스: nums=[1,2,3,4], target=5 -> (0,3) (i 우선)\n- 중복값 케이스: nums=[3,3,4], target=6 -> (0,1)\n- 해 없음 케이스: nums=[1,2], target=10 -> ValueError 발생\n\n**추가 개선**\n- 성능: n이 커질 경우를 대비해 해시맵(값 -> 가장 작은 인덱스 또는 인덱스 리스트)와 이분 탐색으로 최적화해 O(n log k) 또는 O(n)으로 줄일 수 있습니다.\n- 테스트/검증: 랜덤 입력에 대해 O(n^2) 브루트포스와 해시맵 최적화 결과를 비교하는 fuzz 테스트 추가로 신뢰성 확보.\n- API 개선: 예외 대신 None을 반환하거나 에러 타입을 세분화하는 옵션을 제공하여 호출자 요구에 맞춤 가능.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "run_length_compress", "engine": "api-single", "timestamp": "2025-11-15T11:08:21.858658+00:00", "elapsed_sec": 19.207, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n연속된 동일 문자를 스캔해 문자와 카운트를 결합한 스트링을 O(n) 시간·O(1) 추가공간(출력 제외)으로 생성합니다.\n\n**문제 분석**\n- 입력은 ASCII 문자로만 이루어지고 길이는 최대 10^4이며 빈 문자열 가능.\n- 동일 문자가 연속될 때마다 \"<문자><횟수>\" 형태로 이어붙여야 하며, 횟수는 항상 숫자로 표기.\n- 대소문자와 공백·숫자·특수문자 모두 그대로 취급하고 구분함.\n- 외부 라이브러리 사용 금지, 효율적인 문자열 연결(리스트 + join) 권장.\n\n**실행 계획**\n1. 빈 문자열이면 바로 빈 문자열 반환.\n2. 첫 문자로 기준(prev)과 카운트(count)를 초기화.\n3. 문자열을 한 문자씩 순회하면서 현재 문자와 prev를 비교해 같으면 카운트 증가, 다르면 prev와 count를 결과 리스트에 추가하고 prev와 count를 갱신.\n4. 순회 종료 후 마지막 그룹(prev, count)을 결과에 추가하고 리스트를 join하여 반환.\n5. (검증용) 소량의 테스트 케이스를 포함해 출력 확인.\n\n**핵심 코드**\n```python\ndef solution(text: str) -> str:\n    \"\"\"\n    Run-Length Encoding: 연속된 동일 문자를 <문자><횟수> 형태로 인코딩해서 반환.\n    - 빈 문자열이면 빈 문자열 반환\n    - 예: \"aaabb\" -> \"a3b2\", \"ab\" -> \"a1b1\"\n    \"\"\"\n    if not text:\n        return \"\"\n\n    # 결과를 누적할 리스트 (문자와 숫자를 번갈아 추가)\n    parts = []\n    prev = text[0]\n    count = 1\n\n    for ch in text[1:]:\n        if ch == prev:\n            count += 1\n        else:\n            parts.append(prev)\n            parts.append(str(count))\n            prev = ch\n            count = 1\n\n    # 마지막 그룹 추가\n    parts.append(prev)\n    parts.append(str(count))\n\n    return \"\".join(parts)\n\n\n# 간단한 자체 테스트(모듈로 임포트할 때는 실행되지 않음)\nif __name__ == \"__main__\":\n    tests = [\n        (\"\", \"\"),\n        (\"a\", \"a1\"),\n        (\"ab\", \"a1b1\"),\n        (\"aaabbcccc\", \"a3b2c4\"),\n        (\"Aaa 11!!\", \"A1a2 11!2\"),\n        (\"     \", \" 5\"),  # 5개의 공백\n        (\"0122333\", \"01 12 23 33\".replace(\" \", \"\")),  # expected \"01 12 23 33\" -> cleaned to \"01122333\"? (note: here to illustrate)\n    ]\n\n    # Print results\n    for inp, expected in tests:\n        out = solution(inp)\n        print(f\"input: {repr(inp)} -> output: {repr(out)}\")\n```\n\n**테스트 가이드**\n- 빈 문자열: \"\" -> \"\".\n- 단일 문자: \"a\" -> \"a1\".\n- 서로 다른 문자 연속: \"ab\" -> \"a1b1\".\n- 긴 연속 그룹과 혼합: \"aaabbcccc\" -> \"a3b2c4\".\n- 공백/특수문자 포함: \"Aaa 11!!\" -> \"A1a2 11!2\".\n\n**추가 개선**\n- 대량 입력에 대비해 streaming(이터레이터) 입력을 받아 부분 인코딩을 수행하도록 확장 가능.\n- 디코딩 함수(decode)를 함께 제공해 인코딩-디코딩 변환 테스트로 무결성 검사 자동화.\n- 유닛 테스트(pytest) 추가 및 성능 측정을 위한 벤치마크 작성.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "spiral_flatten", "engine": "api-single", "timestamp": "2025-11-15T11:08:52.803539+00:00", "elapsed_sec": 30.928, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n경계 인덱스(top, bottom, left, right)를 좁혀가며 오른쪽→아래→왼쪽→위 순으로 원소를 추가해 새로운 리스트로 반환합니다.\n\n**문제 분석**\n- 입력은 1x1 이상 40x40 이하의 정방/직사각 행렬이며 최소 크기가 보장되지만 빈 입력도 안전하게 처리합니다.\n- 나선형은 (0,0)에서 오른쪽으로 시작하고 시계방향으로 진행합니다.\n- 원본 행렬을 변경하면 안 되므로 결과는 새 리스트로 생성해야 합니다.\n- 시간복잡도는 O(m*n), 추가 공간은 결과 리스트에 해당하는 O(m*n)입니다.\n\n**실행 계획**\n1. 행/열 수를 확인하고 빈 입력이면 빈 리스트 반환.\n2. top, bottom, left, right 경계 인덱스를 초기화한다.\n3. while 루프에서 경계가 유효한 동안:\n   - 위 행을 왼->오로 추가하고 top 증가\n   - 오른쪽 열을 위->아래로 추가하고 right 감소\n   - 아래 행을 오->왼으로 추가하고 bottom 감소 (유효성 확인 후)\n   - 왼쪽 열을 아래->위로 추가하고 left 증가 (유효성 확인 후)\n4. 루프 종료 후 결과 리스트 반환. (입력 불변 보장)\n5. 간단한 self-test 케이스들을 if __name__ == '__main__' 하위에 포함.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    행렬을 나선형(spiral) 순서로 읽어 1차원 리스트로 반환합니다.\n    시작점은 (0,0), 초기 방향은 오른쪽이며 시계방향으로 진행합니다.\n    입력 matrix는 변경하지 않습니다.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        return []\n\n    rows = len(matrix)\n    cols = len(matrix[0])\n    top, bottom = 0, rows - 1\n    left, right = 0, cols - 1\n\n    result: List[int] = []\n\n    while left <= right and top <= bottom:\n        # 위 행: 왼 -> 오\n        for j in range(left, right + 1):\n            result.append(matrix[top][j])\n        top += 1\n\n        # 오른쪽 열: 위 -> 아래\n        for i in range(top, bottom + 1):\n            result.append(matrix[i][right])\n        right -= 1\n\n        # 아래 행: 오 -> 왼 (유효성 검사)\n        if top <= bottom:\n            for j in range(right, left - 1, -1):\n                result.append(matrix[bottom][j])\n            bottom -= 1\n\n        # 왼쪽 열: 아래 -> 위 (유효성 검사)\n        if left <= right:\n            for i in range(bottom, top - 1, -1):\n                result.append(matrix[i][left])\n            left += 1\n\n    return result\n\n\n# 간단한 자가 테스트\nif __name__ == \"__main__\":\n    tests = [\n        ([[1]], [1]),\n        ([[1,2,3]], [1,2,3]),\n        ([[1],[2],[3]], [1,2,3]),\n        ([[1,2],[3,4]], [1,2,4,3]),\n        ([[1,2,3],[4,5,6],[7,8,9]], [1,2,3,6,9,8,7,4,5]),\n        ([[1,2,3,4],[5,6,7,8],[9,10,11,12]], [1,2,3,4,8,12,11,10,9,5,6,7])\n    ]\n\n    for idx, (mat, expected) in enumerate(tests, 1):\n        out = solution(mat)\n        assert out == expected, f\"Test {idx} failed: got {out}, expected {expected}\"\n    print(\"All self-tests passed.\")\n```\n\n**테스트 가이드**\n- 단일 원소: [[1]] → [1]\n- 단일 행 / 단일 열: [[1,2,3]] 및 [[1],[2],[3]] 확인\n- 정방행렬(3x3)과 비정방 행렬(3x4, 4x3)에서 정상 동작 검증\n- 경계 케이스로 빈 리스트 또는 빈 행이 들어오는 경우 빈 리스트 반환 확인\n\n**추가 개선**\n- 제너레이터 버전을 만들어 메모리 사용을 줄이거나 스트리밍 처리 가능하게 확장할 수 있습니다.\n- 입력 검증(숫자 타입 강제, 다른 길이의 행들 허용 여부 등)을 추가하여 더 견고하게 만들 수 있습니다.\n- 대형 행렬에 대한 성능 측정을 위한 벤치마크 및 randomized 테스트 케이스를 추가해 안정성 검증을 자동화하세요.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "bugfix_quixbugs_depth_first_search", "engine": "api-single", "timestamp": "2025-11-15T11:09:31.003348+00:00", "elapsed_sec": 38.183, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n반복형 스택 기반 DFS를 사용해 인접 리스트의 순서를 유지하며 방문 기록을 관리하고, 시작 노드가 없으면 ValueError를 던집니다.\n\n**문제 분석**\n- 방향 그래프는 dict로 주어지고 각 키의 인접 리스트 순서를 그대로 따라야 함.\n- 이미 방문한 노드는 재방문하지 않아야 하며, 순환으로 인한 무한 루프를 피해야 함.\n- 입력 그래프를 수정하면 안 되고, start가 그래프에 없으면 ValueError를 발생시켜야 함.\n- 재귀 깊이 문제를 회피하기 위해 반복(스택) 방식이 안전함.\n\n**실행 계획**\n1. start가 graph의 키에 있는지 검사하고 없으면 ValueError 발생.\n2. 스택에 start를 넣고 루프를 돌며 노드를 pop하여 처리(방문 여부 체크).\n3. 방문 시 결과 리스트에 추가하고 방문 집합에 표시.\n4. 현재 노드의 인접 리스트를 원래 순서대로 방문하려면 스택에 역순으로 push(그래프 변경 금지).\n5. 인접 노드가 graph의 키로 존재하는 경우만 탐색 대상으로 고려(사전 정의된 노드들만 방문).\n\n**핵심 코드**\n```python\nfrom typing import Dict, List, Set\n\ndef solution(graph: Dict[str, List[str]], start: str) -> List[str]:\n    \"\"\"\n    Directed graph DFS that preserves adjacency order.\n    - graph: mapping node -> list of neighbors (order matters)\n    - start: starting node; must be a key in graph\n    Returns list of visited nodes in DFS order.\n    Raises ValueError if start not in graph.\n    \"\"\"\n    if start not in graph:\n        raise ValueError(f\"Start node '{start}' not found in graph\")\n\n    visited: Set[str] = set()\n    order: List[str] = []\n    stack: List[str] = [start]\n\n    while stack:\n        node = stack.pop()\n        if node in visited:\n            continue\n        visited.add(node)\n        order.append(node)\n\n        # Get neighbors without modifying the original graph\n        neighbors = graph.get(node, [])\n        # Push neighbors in reverse so that the leftmost (first) neighbor is processed first\n        for nbr in reversed(neighbors):\n            # Only consider neighbors that are defined in the graph (keys)\n            if nbr in graph and nbr not in visited:\n                stack.append(nbr)\n\n    return order\n```\n\n**테스트 가이드**\n- 선형 그래프: graph = {\"A\": [\"B\"], \"B\": [\"C\"], \"C\": []}, start=\"A\" → [\"A\",\"B\",\"C\"]\n- 사이클 포함: graph = {\"A\":[\"B\"], \"B\":[\"C\"], \"C\":[\"A\"]}, start=\"A\" → 한 번씩만 방문 [\"A\",\"B\",\"C\"]\n- 분기와 순서 보존: graph = {\"A\":[\"B\",\"C\"], \"B\":[\"D\"], \"C\":[\"E\"], \"D\":[], \"E\":[]} start=\"A\" → [\"A\",\"B\",\"D\",\"C\",\"E\"]\n- start가 없음: start=\"X\"이면 ValueError 발생\n\n**추가 개선**\n- 그래프에 인접 리스트에 나타나지만 키가 없는 노드를 \"존재하는 노드(출구가 없는 노드)\"로 취급해 방문하도록 옵션 추가.\n- 재귀 방식도 제공하되 입력 크기에 따라 스택 한계에 대비해 iterative/recursive 선택 가능하도록 컨피그 추가.\n- 더 넓은 테스트를 위해 property-based 테스트(예: Hypothesis)로 다양한 무작위 그래프에서 방문 집합/순서 특성 검증.\n- 성능 측정을 위해 노드 수가 큰 그래프에서 메모리/시간 특성(특히 매우 깊은 체인)에 대한 벤치마크 추가.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "bugfix_swebench_django_slugify", "engine": "api-single", "timestamp": "2025-11-15T11:10:02.947241+00:00", "elapsed_sec": 31.929, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n유니코드 보존 옵션을 올바르게 분리해 공백/밑줄을 하이픈으로 바꾸고, 허용 문자만 남긴 뒤 연속 하이픈을 합쳐 앞뒤 하이픈을 제거하는 안전한 slugify 구현입니다.\n\n**문제 분석**\n- allow_unicode=False일 때는 NFKD 정규화 후 ASCII 외 문자를 완전히 제거해야 함.\n- allow_unicode=True일 때는 한글/라틴 등 유니코드 문자를 보존하되 공백/밑줄은 하이픈으로 바꾸고 영숫자·하이픈만 허용해야 함.\n- 연속된 구분자(공백/밑줄/제거된 문자)로 인해 생긴 다수의 하이픈을 하나로 합치고 양끝 하이픈을 제거해야 함.\n- 입력 문자열은 변경하지 않고 새 문자열을 반환해야 함.\n\n**실행 계획**\n1. 입력을 문자열로 변환하고 allow_unicode에 따라 분기: (a) False이면 NFKD 정규화 후 ASCII로 인코딩/디코드(비ASCII 제거), (b) True이면 원본을 유지.\n2. 전체를 소문자로 변환한다.\n3. 공백과 밑줄을 먼저 하이픈으로 교체한다.\n4. 허용되지 않는 문자를 제거: ASCII 모드와 유니코드 모드에 각각 적합한 정규식을 사용.\n5. 연속된 하이픈을 하나로 합치고 양끝 하이픈을 strip한다.\n6. 최종 문자열을 반환(모두 제거되면 빈 문자열).\n\n**핵심 코드**\n```python\nimport re\nimport unicodedata\n\ndef solution(value: str, allow_unicode: bool = False) -> str:\n    \"\"\"\n    Convert `value` to a URL slug.\n\n    - Default: lowercase, allow only ascii letters/digits/hyphen. spaces and underscores -> hyphen.\n    - allow_unicode=False: normalize NFKD and drop non-ASCII.\n    - allow_unicode=True: preserve unicode letters but allow only letters/digits/hyphen (spaces/underscores -> hyphen).\n    - Collapse multiple hyphens, strip leading/trailing hyphens.\n    - Return new string (do not modify input).\n    \"\"\"\n    if value is None:\n        return ''\n    s = str(value)\n\n    if allow_unicode:\n        # Keep unicode characters; lowercase per Unicode rules\n        s = s.lower()\n        # Replace whitespace and underscores with hyphen\n        s = re.sub(r'[\\s_]+', '-', s, flags=re.U)\n        # Remove anything that's not a word character (letters/digits/underscore) or hyphen.\n        # Underscores already turned to hyphens above; keep hyphen.\n        s = re.sub(r'[^\\w-]', '', s, flags=re.U)\n    else:\n        # Normalize to NFKD and remove non-ascii by encoding with ignore\n        s = unicodedata.normalize('NFKD', s)\n        s = s.encode('ascii', 'ignore').decode('ascii')\n        s = s.lower()\n        # Replace whitespace and underscores with hyphen\n        s = re.sub(r'[\\s_]+', '-', s)\n        # Allow only ascii letters, digits and hyphen\n        s = re.sub(r'[^a-z0-9-]', '', s)\n\n    # Collapse multiple hyphens and strip leading/trailing hyphens\n    s = re.sub(r'-{2,}', '-', s)\n    s = s.strip('-')\n\n    return s\n```\n\n**테스트 가이드**\n- \"Hello, World!\" -> \"hello-world\"\n- \"Café au lait\" -> allow_unicode=False => \"cafe-au-lait\", allow_unicode=True => \"café-au-lait\"\n- \"___Multiple   Separators__And---punct!!\" -> \"multiple-separators-and-punct\"\n- \"안녕하세요 세계\" -> allow_unicode=True => \"안녕하세요-세계\", allow_unicode=False => \"\" (모두 제거되어 빈 문자열)\n\n**추가 개선**\n- 정규식 패턴과 컴파일된 객체를 모듈 수준에서 미리 생성해 성능 개선 가능.\n- 로컬/언어별 소문자화 이슈(예: 터키어 i)를 고려한 옵션 추가 또는 locale-aware lower 처리.\n- separator(하이픈) 커스터마이징, 최대 길이 제한, 접두/접미사 옵션 등의 확장.\n- 유닛 테스트를 추가해 다양한 스크립트(라틴, 한글, 아랍어 등)와 결합 문자 케이스를 검증.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "sum_even_numbers", "engine": "api-single", "timestamp": "2025-11-15T11:10:20.403198+00:00", "elapsed_sec": 17.439, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n단일 선형 스캔으로 입력 리스트를 변경하지 않고 짝수 원소만 필터해 합을 구합니다.\n\n**문제 분석**\n- 입력 길이는 0에서 100000 사이이므로 O(n) 한 번 순회로 해결해야 성능·메모리 안전.\n- nums 자체를 변경하지 않아야 하므로 원본을 건드리지 않고 읽기 전용으로 처리.\n- 짝수 값(음수 포함)을 모두 더하고, 짝수가 없으면 0 반환.\n- Python의 sum()과 제너레이터 표현식을 사용하면 간결하고 메모리 효율적.\n\n**실행 계획**\n1. 입력이 리스트임을 전제로, 각 원소를 한 번씩 순회한다.\n2. 각 원소가 2로 나누어 떨어지는지(x % 2 == 0) 검사하여 짝수인 값만 선택한다.\n3. 선택된 값들을 누적하여 합을 반환한다 (값이 없으면 sum이 자동으로 0을 반환).\n4. nums를 수정하지 않도록 읽기 전용 접근만 사용하고, 대용량에서도 메모리 부담이 없게 제너레이터를 사용한다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int]) -> int:\n    \"\"\"\n    nums의 짝수 원소들만 더한 합을 반환합니다.\n    nums는 변경하지 않습니다.\n    시간복잡도: O(n), 추가공간: O(1) (제너레이터 사용)\n    \"\"\"\n    # 제너레이터 표현식으로 메모리 사용 최소화\n    return sum(x for x in nums if x % 2 == 0)\n\n# 간단한 자기검증용 테스트 케이스들\nif __name__ == \"__main__\":\n    # 빈 리스트 -> 0\n    assert solution([]) == 0\n\n    # 짝수/홀수 섞임\n    assert solution([1, 2, 3, 4, 5, 6]) == 2 + 4 + 6\n\n    # 음수 짝수 포함\n    assert solution([-4, -3, -2, 1]) == -6\n\n    # 모두 홀수 -> 0\n    assert solution([1, 3, 5, 7]) == 0\n\n    # 큰 입력 시 성능(간단한 크기 체크)\n    big = [i for i in range(100000)]\n    expected = sum(i for i in big if i % 2 == 0)\n    assert solution(big) == expected\n\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 빈 리스트: solution([]) -> 0\n- 섞인 케이스: [1,2,3,4,5,6] -> 12\n- 음수 포함: [-4,-3,-2,1] -> -6\n- 모든 홀수: [1,3,5] -> 0\n\n**추가 개선**\n- 입력 검증 추가: 리스트 또는 반복 가능한 정수 시퀀스인지 확인하고, 잘못된 타입에 대해 명확한 예외를 던지기.\n- 큰 정수나 다양한 수치 타입(예: numpy 배열) 지원을 위해 별도 최적화(벡터화)를 제공하는 래퍼 함수 추가.\n- 병렬 처리(멀티스레드/멀티프로세스)는 단순 합계에는 오버헤드가 크지만, 매우 큰 입력과 복잡한 필터가 결합될 때 고려 가능.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "count_vowels", "engine": "api-single", "timestamp": "2025-11-15T11:10:44.251334+00:00", "elapsed_sec": 23.83, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n문자열을 한 번 순회하며 소문자 기준의 모음 집합과 비교해 카운트하는 O(n) 시간/O(1) 추가공간 해결.\n\n**문제 분석**\n- 모음은 a, e, i, o, u (대소문자 구분하지 않음)으로 정의\n- 알파벳이 아닌 문자는 무시(단순히 모음 여부만 검사하면 됨)\n- 입력 길이 최대 10^5이므로 선형 시간 알고리즘 필요\n- 메모리 제한을 고려해 추가 구조는 작은 상수 크기 사용\n\n**실행 계획**\n1. 모음을 빠르게 검사할 수 있도록 상수 크기의 집합(vowels)을 준비한다.\n2. 입력 문자열을 한 번 순회하여 각 문자를 소문자화(casefold 권장)한 뒤 집합에 포함되는지 확인한다.\n3. 포함되면 카운터를 증가시키고, 끝나면 카운터 반환한다.\n4. 간단한 자기검증을 위해 대표 케이스에 대한 assert 테스트를 main 블록에 추가한다.\n\n**핵심 코드**\n```python\nfrom typing import Any\n\ndef solution(text: str) -> int:\n    \"\"\"\n    주어진 영문 문자열에서 모음(a,e,i,o,u)의 개수를 반환합니다.\n    대소문자 구분하지 않으며 알파벳 이외의 문자는 무시됩니다.\n\n    복잡도: O(n) 시간, O(1) 추가공간\n    \"\"\"\n    if not isinstance(text, str):\n        # 안전성: 비문자열 입력이 들어오면 문자열로 변환하여 처리\n        text = str(text)\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\n    # casefold는 lower보다 더 광범위한 소문자화(국제문자에도 유리)\n    count = 0\n    for ch in text.casefold():\n        # 모음 집합에 있는지 검사(숫자나 특수문자는 자연스럽게 제외됨)\n        if ch in vowels:\n            count += 1\n    return count\n\n\nif __name__ == \"__main__\":\n    # 기본적인 자기검증 테스트\n    tests = [\n        (\"Hello, World!\", 3),      # e, o, o\n        (\"AEIOUaeiou\", 10),        # 모두 모음\n        (\"bcdfg\", 0),              # 모음 없음\n        (\"Th3 qu1ck br0wn!\", 1),   # u 만 모음 (숫자 0은 문자 'o' 아님)\n        (\"\", 0),                   # 빈 문자열\n        (\"Pneumonoultramicroscopicsilicovolcanoconiosis\", 20),  # 긴 단어\n    ]\n\n    for s, expected in tests:\n        result = solution(s)\n        assert result == expected, f\"테스트 실패: 입력={s!r}, 예상={expected}, 실제={result}\"\n    print(\"모든 기본 테스트 통과\")\n```\n\n**테스트 가이드**\n- 단순 케이스: \"Hello\" -> 2 (e, o)\n- 대소문자 혼합: \"AbEcIdO\" -> 각 모음 카운트 확인\n- 숫자/특수문자 포함: \"Th3 qu1ck br0wn!\" -> 숫자 '0'이 알파벳 o로 카운트되지 않음을 확인\n- 최대 길이 스트레스: 길이 100000의 랜덤 문자열에서 성능 확인\n\n**추가 개선**\n- 성능: 매우 큰 입력(수백 MB)을 처리할 경우 스트리밍(청크 단위 처리)으로 메모리 사용을 줄이기.\n- 확장성: 언어별 모음 정의를 파라미터화하여 다른 알파벳(예: y 포함, 액센트 문자 등)도 지원하도록 옵션 추가.\n- 테스트: property-based 테스트(예: hypothesis)를 도입해 다양한 유니코드/경계 케이스 검증.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "reverse_words", "engine": "api-single", "timestamp": "2025-11-15T11:11:03.803804+00:00", "elapsed_sec": 19.537, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n입력 문자열을 공백 기준으로 분리한 뒤 단어 순서를 뒤집고 단어 사이를 단일 공백으로 연결해 반환합니다.\n\n**문제 분석**\n- 단어는 하나 이상의 공백이 아닌 문자 연속으로 정의되므로 연속 공백은 구분자 역할을 합니다.\n- 결과는 앞뒤 공백 제거, 단어 사이 단일 공백 사용, 빈 입력(또는 모두 공백)은 빈 문자열 반환.\n- 구현은 시간 복잡도 O(n)과 추가 메모리 O(n)이면 충분합니다.\n\n**실행 계획**\n1. 입력 문자열의 양끝 공백을 명시적으로 제거하지 않고, str.split()을 사용해 연속된 공백을 자동으로 구분자 처리합니다.\n2. 분리된 단어 리스트를 뒤집습니다.\n3. reversed 리스트를 ' '.join으로 단일 공백으로 연결합니다.\n4. 빈 리스트(입력이 빈 문자열 또는 공백만 있는 경우)는 빈 문자열 반환으로 처리합니다.\n\n**핵심 코드**\n```python\ndef solution(text: str) -> str:\n    \"\"\"\n    주어진 문자열 text의 단어 순서를 뒤집어 반환한다.\n    - 단어는 공백이 아닌 문자들의 연속\n    - 단어 사이의 공백 수는 무시하고 결과에서는 단일 공백으로 연결\n    - 양끝 공백은 제거\n    \"\"\"\n    # str.split()은 연속된 공백을 구분자처럼 취급하고,\n    # 결과에 빈 문자열을 포함하지 않으므로 요구사항과 일치한다.\n    words = text.split()\n    if not words:\n        return \"\"\n    # reversed(words) 또는 words[::-1] 사용 가능\n    return \" \".join(reversed(words))\n\n\n# 간단한 자체 검증(직접 실행 시)\nif __name__ == \"__main__\":\n    tests = [\n        (\"  hello   world  \", \"world hello\"),\n        (\"single\", \"single\"),\n        (\"   \", \"\"),\n        (\"a b   c    d\", \"d c b a\"),\n        (\" leading\", \"leading\"),\n        (\"trailing \", \"trailing\"),\n        (\" multiple\\twhitespace\\nkinds \", \"kinds whitespace multiple\"),\n    ]\n\n    for inp, expected in tests:\n        out = solution(inp)\n        print(f\"IN: {repr(inp)} -> OUT: {repr(out)} (EXPECTED: {repr(expected)})\")\n        assert out == expected, f\"Failed for input: {inp}\"\n    print(\"All tests passed.\")\n```\n\n**테스트 가이드**\n- 기본: \"  hello   world  \" -> \"world hello\"\n- 단어 하나만 있는 경우: \"single\" -> \"single\"\n- 공백만 있는 입력: \"   \" -> \"\"\n- 여러 형태의 공백(탭/개행 포함): \"a\\tb\\nc\" -> \"c b a\"\n\n**추가 개선**\n- 현재 구현은 Python의 str.split()에 의존해 모든 유니코드 공백을 구분하므로 일반적 요구에는 충분하나, 특정 공백 문자만 허용/제거해야 하면 정규표현식(re.split)을 사용해 제어 가능.\n- 입력이 매우 클 때(예: 스트리밍 텍스트) 메모리 사용을 줄이기 위해 파일/스트림을 뒤에서부터 읽어 단어를 출력하는 스트리밍 방식 구현 고려.\n- 더 엄격한 검증을 위해 pytest 기반 유닛 테스트와 다양한 유니코드 입력 케이스를 추가해서 레거시 플랫폼 호환성 확인.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "unique_elements_count", "engine": "api-single", "timestamp": "2025-11-15T11:11:21.078518+00:00", "elapsed_sec": 17.258, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n정수 리스트의 서로 다른 원소 개수를 O(n) 시간/공간 복잡도로 계산하기 위해 파이썬 내장 set을 사용합니다.\n\n**문제 분석**\n- 입력 리스트 길이는 최대 10^5, 값 범위는 정수의 일반 범위(절댓값 ≤ 10^9)로 해시 가능한 int임.\n- 중복을 제거하고 서로 다른 원소의 개수를 반환하면 되므로 집합(set) 사용이 적합.\n- 빈 리스트 처리(0 반환)와 음수/0 포함 값을 정상 처리해야 함.\n\n**실행 계획**\n1. 입력이 리스트 타입이며 요소가 정수라는 전제하에 그대로 처리(추가 검증이 필요하면 간단 체크 추가).\n2. 리스트를 set으로 변환하여 해시 기반으로 중복을 제거.\n3. set의 길이를 반환하여 서로 다른 원소의 개수를 얻음.\n4. 간단한 단위 테스트(빈 리스트, 모두 동일, 모두 다른, 음수 포함 혼합)를 포함해 동작을 검증.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int]) -> int:\n    \"\"\"\n    정수 리스트 nums에서 서로 다른 원소의 개수를 반환합니다.\n    시간 복잡도: O(n), 공간 복잡도: O(k) (k는 서로 다른 원소 수)\n    \"\"\"\n    # 입력이 None일 가능성에 대비 (명세상 불필요할 수 있음)\n    if nums is None:\n        return 0\n    # 파이썬의 set은 해시 기반으로 중복을 제거하므로 간단하고 빠름\n    return len(set(nums))\n\n\nif __name__ == \"__main__\":\n    # 기본적인 동작 검증 (간단한 단위 테스트)\n    assert solution([]) == 0, \"빈 리스트는 0\"\n    assert solution([1, 1, 1, 1]) == 1, \"모두 같으면 1\"\n    assert solution([1, 2, 3, 4, 5]) == 5, \"모두 다르면 길이 반환\"\n    assert solution([0, -1, -1, 2, 0, 3]) == 4, \"음수 및 중복 혼합\"\n    # 랜덤 큰 입력 테스트(성능 검사용, 주석 처리 가능)\n    # import random\n    # big = [random.randint(-10**9, 10**9) for _ in range(10**5)]\n    # _ = solution(big)\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 빈 리스트 -> 0 반환.\n- 모든 요소가 동일한 리스트 -> 1 반환.\n- 모든 요소가 서로 다른 리스트 -> 리스트 길이 반환.\n- 음수, 0, 양수가 섞인 리스트에서 중복 제거 후 정확한 개수 반환.\n\n**추가 개선**\n- 입력 타입이 명확하지 않은 경우 요소 타입 검사(예: int 아닌 값이 섞여있을 때 예외 처리) 추가.\n- 입력이 매우 커서 메모리 제약이 있는 환경에서는 외부 정렬/스트리밍-해시 기법을 사용해 메모리 사용량을 줄이는 방법 고려.\n- 성능 중요하면 C 확장 또는 PyPy 사용으로 집합 연산 성능을 더 끌어올릴 수 있음.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "prefix_sums", "engine": "api-single", "timestamp": "2025-11-15T11:11:35.003708+00:00", "elapsed_sec": 13.905, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n입력 리스트를 변경하지 않고 단일 누적 합(running total)을 계산해 O(n) 시간·O(n) 추가 메모리로 prefix sum 리스트를 반환합니다.\n\n**문제 분석**\n- 반환 리스트의 i번째 원소는 nums[0]부터 nums[i]까지의 합이어야 함.\n- 빈 입력이면 빈 리스트 반환.\n- 입력 리스트(nums)는 변경해서는 안 됨(불변성 보장).\n- 시간 복잡도 O(n), 추가 메모리 O(n)가 목표.\n\n**실행 계획**\n1. 빈 리스트인 경우 즉시 빈 리스트 반환.\n2. 누적 합을 저장할 변수(total)를 0으로 초기화.\n3. 입력을 순회하면서 각 원소를 total에 더하고 결과 리스트에 append.\n4. 입력 리스트의 값이 변경되지 않았는지(복사 검사)와 여러 대표 케이스에 대해 간단한 단위 테스트를 수행.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int]) -> List[int]:\n    \"\"\"\n    nums의 prefix sum을 계산하여 새로운 리스트로 반환합니다.\n    입력 리스트는 변경되지 않습니다.\n\n    예:\n      nums = [1, 2, 3] -> [1, 3, 6]\n      nums = [] -> []\n    \"\"\"\n    if not nums:\n        return []\n    res: List[int] = []\n    total = 0\n    for x in nums:\n        total += x\n        res.append(total)\n    return res\n\n# 간단한 자체 검증(스크립트로 실행할 때만 수행)\nif __name__ == \"__main__\":\n    # 테스트 케이스들\n    cases = [\n        ([], []),\n        ([5], [5]),\n        ([1, 2, 3, 4], [1, 3, 6, 10]),\n        ([0, -1, 3, -2], [0, -1, 2, 0]),\n    ]\n\n    for inp, expected in cases:\n        # 입력이 변경되지 않았는지 확인하기 위해 복사본 생성\n        original_copy = list(inp)\n        out = solution(inp)\n        assert out == expected, f\"입력 {inp} -> 예상 {expected}, 결과 {out}\"\n        assert inp == original_copy, f\"함수 호출로 입력이 변경됨: {inp} != {original_copy}\"\n\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 빈 리스트: [] -> []\n- 단일 원소: [5] -> [5]\n- 일반 양수 리스트: [1,2,3,4] -> [1,3,6,10]\n- 음수/영 포함: [0,-1,3,-2] -> [0,-1,2,0]\n\n**추가 개선**\n- 표준 라이브러리 사용: itertools.accumulate를 사용하면 구현이 더 간결해짐 (단, 리스트로 반환 필요).\n- 큰 입력/성능: 메모리 절약을 위해 제너레이터로 누적 합 스트림을 제공하거나, numpy를 사용해 벡터화 연산으로 속도 개선 가능.\n- 안정성: 입력 타입 검증(모든 요소가 정수인지) 또는 유닛 테스트 프레임워크(pytest) 기반 테스트 스위트 추가.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "merge_sorted_lists", "engine": "api-single", "timestamp": "2025-11-15T11:11:56.681700+00:00", "elapsed_sec": 21.661, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n두 포인터를 사용해 입력 리스트를 변경하지 않고 O(n+m) 시간에 새 오름차순 리스트를 생성해 반환합니다.\n\n**문제 분석**\n- 입력 a, b는 이미 오름차순 정렬되어 있으며, 결과도 오름차순이어야 함.\n- 입력 리스트를 변경하면 안 되므로 새 리스트를 반환해야 함.\n- 시간 복잡도는 각 원소를 한 번만 처리하는 O(len(a)+len(b))가 적절함.\n- 중복 값, 음수, 빈 리스트 등 모든 일반적인 케이스를 처리해야 함.\n\n**실행 계획**\n1. 두 리스트의 길이를 가져오고 인덱스 i, j를 0으로 초기화한다.\n2. i와 j가 각각 리스트 끝에 도달할 때까지 두 포인터가 가리키는 값을 비교하여 작은 값을 결과 리스트에 추가한다.\n3. 한쪽 리스트가 먼저 소진되면 나머지 원소들을 결과에 한 번에 추가한다.\n4. 입력 리스트를 수정하지 않음을 보장하고, 간단한 테스트(빈 리스트, 중복, 음수 포함)로 동작을 검증한다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(a: List[int], b: List[int]) -> List[int]:\n    \"\"\"\n    오름차순으로 정렬된 두 정수 리스트 a, b를 병합하여\n    모든 원소를 포함하는 새로운 오름차순 리스트를 반환합니다.\n    입력 리스트는 변경하지 않습니다.\n    \"\"\"\n    n, m = len(a), len(b)\n    i = j = 0\n    merged: List[int] = []\n\n    # 두 포인터로 병합\n    while i < n and j < m:\n        if a[i] <= b[j]:\n            merged.append(a[i])\n            i += 1\n        else:\n            merged.append(b[j])\n            j += 1\n\n    # 남은 원소들 추가 (슬라이스로 복사하여 입력 변경 없음)\n    if i < n:\n        merged.extend(a[i:])\n    if j < m:\n        merged.extend(b[j:])\n\n    return merged\n\n# 간단한 자기 검증 테스트 (프로덕션 코드에서는 별도 테스트 파일 권장)\nif __name__ == \"__main__\":\n    assert solution([], []) == []\n    assert solution([1, 3, 5], []) == [1, 3, 5]\n    assert solution([], [2, 4]) == [2, 4]\n    assert solution([1, 2, 4], [2, 3, 5]) == [1, 2, 2, 3, 4, 5]\n    assert solution([-3, 0, 1], [-2, 0, 2]) == [-3, -2, 0, 0, 1, 2]\n    print(\"모든 내장 테스트 통과\")\n```\n\n**테스트 가이드**\n- 빈 리스트들: a = [], b = [] → []\n- 한 쪽만 비어있음: a = [1,3,5], b = [] → [1,3,5]\n- 중복값 포함: a = [1,2,4], b = [2,3,5] → [1,2,2,3,4,5]\n- 음수 및 0 포함: a = [-5,-1,0], b = [-3,2] → [-5,-3,-1,0,2]\n\n**추가 개선**\n- 입력이 매우 커서 메모리 제한이 있는 경우 제너레이터를 반환하도록 변경해 한 번에 하나씩 소비하는 스트리밍 병합 구현을 제공할 수 있음.\n- 타입/값 검증(예: 각 리스트가 정렬되어 있는지 검사)을 선택적 디버그 모드에서 추가하면 잘못된 입력을 조기에 탐지할 수 있음.\n- 단위 테스트 프레임워크(pytest)를 이용해 다양한 경계 케이스, 랜덤 케이스를 자동화하고 성능(시간/메모리) 측정을 포함하도록 확장 가능.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "is_anagram", "engine": "api-single", "timestamp": "2025-11-15T11:12:17.778298+00:00", "elapsed_sec": 21.08, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n대소문자 구분 없이 모든 공백 문자를 제거한 뒤 문자 빈도(multiset)를 비교해 애너그램 여부를 결정합니다.\n\n**문제 분석**\n- 입력 문자열의 모든 종류의 공백(스페이스, 탭, 개행 등)을 무시해야 합니다.\n- 대소문자를 구분하지 않으므로 비교 전 소문자(또는 대문자)로 정규화합니다.\n- 문자들의 개수(빈도)를 비교해야 하므로 정렬하거나 카운터 비교가 적합합니다.\n- 수행 시간은 입력 길이에 비례한 O(n), 추가 메모리는 문자 종류 수에 비례하도록 구현합니다.\n\n**실행 계획**\n1. 두 문자열 각각에서 모든 공백 문자를 제거하고 소문자로 정규화합니다.\n2. 정규화된 문자열들의 길이가 다르면 즉시 False를 반환합니다.\n3. collections.Counter를 사용해 각 문자열의 문자 빈도를 계산합니다.\n4. 두 Counter를 비교하여 같으면 True, 다르면 False를 반환합니다.\n5. 간단한 단위 테스트(일반/대소문자/공백/빈 문자열/다른 문자 등)로 동작을 확인합니다.\n\n**핵심 코드**\n```python\nfrom collections import Counter\nfrom typing import Iterable\n\ndef _normalize(s: str) -> Iterable[str]:\n    \"\"\"\n    모든 공백 문자를 제거하고 소문자로 정규화한 문자 이터레이터를 반환.\n    (문자열 전체를 메모리에 복사하는 대신 이터레이터를 통해 처리할 수 있음)\n    \"\"\"\n    for ch in s:\n        if not ch.isspace():\n            yield ch.lower()\n\ndef solution(s: str, t: str) -> bool:\n    \"\"\"\n    두 문자열이 애너그램인지 판별합니다.\n    - 공백 문자는 모두 무시\n    - 대소문자 구분 없음\n    \"\"\"\n    # 정규화된 문자열을 리스트로 만들어 길이를 비교하여 빠르게 배제\n    ns = ''.join(_normalize(s))\n    nt = ''.join(_normalize(t))\n\n    if len(ns) != len(nt):\n        return False\n\n    return Counter(ns) == Counter(nt)\n\n\n# 간단한 자체 테스트\nif __name__ == \"__main__\":\n    tests = [\n        (\"Listen\", \"Silent\", True),\n        (\"A gentleman\", \"Elegant man\", True),\n        (\"Dormitory\", \"Dirty room\", True),\n        (\"Hello\", \"Olelh\", True),\n        (\"Hello \", \"Oleh\", False),       # 길이 불일치\n        (\"Conversation\", \"Voices rant on\", True),\n        (\"abc\", \"abć\", False),          # 다른 유니코드 문자\n        (\"\", \"\", True),\n        (\"   \\t\\n\", \"\", True),\n        (\"a b c\", \"abc \", True),\n    ]\n\n    for a, b, expected in tests:\n        res = solution(a, b)\n        print(f\"{a!r} vs {b!r} -> {res} (expected: {expected})\")\n        assert res == expected, f\"Test failed for: {a!r} vs {b!r}\"\n\n    print(\"All self-tests passed.\")\n```\n\n**테스트 가이드**\n- 대소문자가 다른 경우: (\"Listen\", \"Silent\") -> True\n- 공백이 다양한 위치/종류인 경우: (\"A gentleman\", \"Elegant\\tman\") -> True\n- 빈 문자열 혹은 공백만 있는 문자열: (\"   \", \"\") -> True\n- 문자의 종류가 다른 경우: (\"abc\", \"abć\") -> False\n\n**추가 개선**\n- 메모리/성능: 매우 긴 문자열에서는 Counter 대신 두 해시맵을 직접 업데이트하여 초기에 길이 체크 없이 한 번의 순회로 판별하도록 최적화 가능(스트리밍 방식).\n- 로케일/유니코드 정규화: 입력이 복잡한 유니코드(결합문자 등)를 포함할 경우 unicodedata.normalize('NFC'/'NFD')를 적용해 동일 문자의 정규화를 보장.\n- 테스트 자동화: pytest 기반의 단위 테스트 추가 및 property-based testing(hypothesis)로 다양한 임의 문자열 케이스 검증.\n- 안전성: 타입 검증이나 None 입력에 대한 명확한 동작 정의(예: None 입력 시 TypeError 발생 또는 False 반환) 추가.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "balanced_parentheses", "engine": "api-single", "timestamp": "2025-11-15T11:12:40.714614+00:00", "elapsed_sec": 22.921, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n스택을 사용해 여는 괄호는 푸시하고 닫는 괄호는 스택에서 대응 여는 괄호를 팝하여 검사하는 방식으로 문자열의 괄호 균형을 선형 시간에 판별합니다.\n\n**문제 분석**\n- 입력 문자열 s는 괄호 외 임의의 문자를 포함할 수 있으므로 괄호 문자만 처리해야 함.\n- 처리해야 할 괄호 종류는 '()', '[]', '{}' 세 종류이며 중첩과 순서가 정확해야 True.\n- 빈 문자열은 True.\n- 시간 복잡도는 O(n), 추가 메모리는 스택 크기(최악의 경우 O(n)).\n\n**실행 계획**\n1. 닫는 괄호 -> 대응 여는 괄호 매핑 사전 정의하고, 여는 괄호 집합도 준비.\n2. 문자열을 처음부터 끝까지 순회하면서:\n   - 문자가 여는 괄호면 스택에 push.\n   - 문자가 닫는 괄호면 스택 top과 비교 후 일치하면 pop, 아니면 즉시 False 반환.\n   - 기타 문자면 무시.\n3. 순회 종료 후 스택이 비어 있으면 True, 그렇지 않으면 False 반환.\n4. (검증용) 몇 가지 대표 케이스로 함수 동작을 확인하는 간단한 테스트를 포함.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(s: str) -> bool:\n    \"\"\"\n    문자열 s에서 '()', '[]', '{}' 세 종류의 괄호만 고려하여\n    괄호들이 올바르게 짝지어져 있고 중첩이 올바르면 True, 아니면 False 반환.\n    \"\"\"\n    # 닫는 괄호 -> 여는 괄호 매핑\n    closing_to_open = {')': '(', ']': '[', '}': '{'}\n    opens = set(closing_to_open.values())\n    stack: List[str] = []\n\n    for ch in s:\n        if ch in opens:\n            stack.append(ch)\n        elif ch in closing_to_open:\n            if not stack:\n                return False\n            if stack.pop() != closing_to_open[ch]:\n                return False\n        # 다른 문자는 무시\n\n    return not stack\n\n\n# 간단한 실행 테스트 (직접 실행 시에만 동작)\nif __name__ == \"__main__\":\n    tests = {\n        \"\": True,\n        \"()\": True,\n        \"([]{})\": True,\n        \"([)]\": False,\n        \"a(b[c]{d}e)f\": True,\n        \"({[})]\": False,\n        \"((((\": False,\n        \"no brackets here\": True,\n        \"[(])\": False,\n        \"]{\": False,\n    }\n\n    all_ok = True\n    for inp, expected in tests.items():\n        res = solution(inp)\n        ok = res == expected\n        all_ok = all_ok and ok\n        print(f\"{repr(inp):30} -> {res} (expected {expected}) {'OK' if ok else 'FAIL'}\")\n\n    if all_ok:\n        print(\"All sample tests passed.\")\n    else:\n        print(\"Some sample tests failed.\")\n```\n\n**테스트 가이드**\n- 빈 문자열: \"\" -> True\n- 올바른 중첩 및 다른 문자 포함: \"a(b[c]{d}e)f\" -> True\n- 잘못된 중첩/순서: \"([)]\", \"[(])\" -> False\n- 괄호만 많은 불균형: \"((((\" 또는 \")]{\" -> False\n\n**추가 개선**\n- 스트리밍 입력(매우 긴 입력이나 실시간 검사)에서 부분적으로 처리할 수 있게 제너레이터 기반 인터페이스 추가.\n- 오류 위치(문자 인덱스)나 예상되는 여는 괄호 정보를 반환하도록 확장하면 디버깅에 유용.\n- 다양한 괄호(예: Unicode 화살표형 괄호 등)를 지원하려면 매핑을 외부에서 주입하도록 구성.\n- 프로퍼티 기반(Hypothesis) 테스트나 더 많은 경계 케이스(대량 임의 문자열)로 강건성 검증.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "interval_merge", "engine": "api-single", "timestamp": "2025-11-15T11:13:00.523554+00:00", "elapsed_sec": 19.792, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n정렬 후 인접하거나 겹치는 닫힌 구간들을 병합하여 시작점 오름차순의 튜플 리스트로 반환합니다.\n\n**문제 분석**\n- 입력은 (start, end) 튜플들의 리스트이며 start <= end가 보장됩니다.\n- 닫힌 구간이므로 겹치거나 맞닿는 경우(다음.start <= 현재.end)에도 병합해야 합니다.\n- 입력 리스트는 변경하지 않고, 결과는 시작점 오름차순으로 정렬된 튜플 리스트여야 합니다.\n- 시간복잡도는 정렬을 포함해 O(n log n), 추가 메모리는 O(n) 허용.\n\n**실행 계획**\n1. 입력 리스트의 변경을 피하기 위해 얕은 복사본을 만든 뒤 시작점을 기준으로 정렬합니다(동일 시작은 끝점으로 보조 정렬).\n2. 정렬된 리스트를 한 번 순회하며 현재 병합 중인 구간(cur_start, cur_end)을 유지합니다.\n3. 다음 구간의 start가 cur_end 이하이면(겹치거나 맞닿음) end를 확장하여 병합합니다.\n4. 그렇지 않으면 현재 병합 구간을 결과에 추가하고 다음 구간으로 교체합니다. 순회 종료 후 남은 병합 구간을 추가합니다.\n5. 결과는 각 구간을 튜플로 반환하여 원래 입력과 독립성을 유지합니다.\n\n**핵심 코드**\n```python\nfrom typing import List, Tuple\n\ndef solution(intervals: List[Tuple[int, int]]) -> List[Tuple[int, int]]:\n    \"\"\"\n    주어진 닫힌 구간 리스트를 병합하여 시작점 오름차순으로 반환합니다.\n    입력 리스트는 변경하지 않습니다.\n    \"\"\"\n    # 빠른 처리: 빈 입력\n    if not intervals:\n        return []\n\n    # 입력 변경 금지: 복사 후 정렬 (start, end)\n    intervals_sorted = sorted(list(intervals), key=lambda iv: (iv[0], iv[1]))\n\n    merged: List[Tuple[int, int]] = []\n    cur_start, cur_end = intervals_sorted[0]\n\n    for s, e in intervals_sorted[1:]:\n        # 닫힌 구간이므로 맞닿거나 겹치면 병합\n        if s <= cur_end:\n            # end를 확장할 필요가 있을 때만 갱신\n            if e > cur_end:\n                cur_end = e\n        else:\n            merged.append((cur_start, cur_end))\n            cur_start, cur_end = s, e\n\n    # 마지막 병합 구간 추가\n    merged.append((cur_start, cur_end))\n    return merged\n\n# 간단한 실행 예제 (직접 실행 시)\nif __name__ == \"__main__\":\n    examples = [\n        ([(1,3), (2,6), (8,10), (15,18)], [(1,6), (8,10), (15,18)]),\n        ([(1,4), (4,5)], [(1,5)]),  # 맞닿는 경우 병합\n        ([], []),\n        ([(5,5), (5,5)], [(5,5)]),  # 동일 점 구간 병합\n    ]\n    for inp, expected in examples:\n        out = solution(inp)\n        print(f\"in: {inp} -> out: {out} | expected: {expected} | ok: {out == expected}\")\n```\n\n**테스트 가이드**\n- 기본 겹침: [(1,3),(2,6),(8,10)] -> [(1,6),(8,10)]\n- 맞닿음 포함: [(1,4),(4,5)] -> [(1,5)]\n- 단일 점 구간 및 중복: [(5,5),(5,5)] -> [(5,5)]\n- 빈 입력: [] -> []\n\n**추가 개선**\n- 입력 검증 추가: 각 튜플이 두 원소인지, start <= end인지 예외 처리.\n- 병합 기준을 커스텀(예: 열린구간 처리, 최소 간격 허용)하도록 파라미터화.\n- 대규모 스트림 데이터용으로 정렬 없이 선형 병합(예: 이미 정렬된 입력에 대한 최적화) 또는 외부 정렬을 사용한 메모리 절약 버전 구현.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "matrix_transpose", "engine": "api-single", "timestamp": "2025-11-15T11:13:23.944917+00:00", "elapsed_sec": 23.406, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n새 리스트를 만들어 입력 직사각행렬의 전치 행렬을 반환합니다.\n\n**문제 분석**\n- 입력 matrix는 0x0이 아닌 직사각(모든 행의 길이가 동일) 정수 행렬이다.\n- 원본 matrix를 수정하면 안 되므로 새로운 리스트 구조를 만들어 반환해야 한다.\n- 시간복잡도 O(rows * cols), 공간복잡도 O(rows * cols)로 해결 가능하다.\n\n**실행 계획**\n1. 입력 유효성 검사: 비어있거나 0x0인 경우 또는 직사각이 아닌 경우 예외 발생.\n2. 행(row) 수와 열(column) 수를 계산한다.\n3. 새로운 리스트를 생성: 결과의 행 개수는 원래의 열 개수, 열 개수는 원래의 행 개수.\n4. 중첩 반복문(혹은 리스트 컴프리헨션)으로 전치 원소를 채우고 반환한다.\n5. 간단한 단위 테스트로 동작과 원본 불변성을 검증한다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(matrix: List[List[int]]) -> List[List[int]]:\n    \"\"\"\n    주어진 직사각 행렬 matrix의 전치 행렬을 새 리스트로 만들어 반환한다.\n    원본 matrix는 수정하지 않는다.\n    \"\"\"\n    if not matrix or not matrix[0]:\n        raise ValueError(\"matrix는 비어있지 않아야 합니다 (0x0 금지).\")\n    rows = len(matrix)\n    cols = len(matrix[0])\n    # 직사각 검사\n    for r in matrix:\n        if len(r) != cols:\n            raise ValueError(\"matrix는 직사각(모든 행의 길이가 동일)이어야 합니다.\")\n    # 전치 생성: result[c][r] = matrix[r][c]\n    result: List[List[int]] = [[matrix[r][c] for r in range(rows)] for c in range(cols)]\n    return result\n\n# 간단한 테스트 허브\nif __name__ == \"__main__\":\n    tests = [\n        # (input, expected)\n        ([[1]], [[1]]),\n        ([[1, 2, 3], [4, 5, 6]], [[1, 4], [2, 5], [3, 6]]),\n        ([[1, 2], [3, 4], [5, 6]], [[1, 3, 5], [2, 4, 6]]),\n        ([[0, -1], [2, 3]], [[0, 2], [-1, 3]]),\n    ]\n    for i, (inp, expected) in enumerate(tests, start=1):\n        # 원본 불변성 확인을 위해 호출 전 복사본을 보관\n        original_copy = [row[:] for row in inp]\n        out = solution(inp)\n        assert out == expected, f\"테스트 {i} 실패: 출력 {out}, 기대 {expected}\"\n        assert inp == original_copy, f\"테스트 {i} 실패: 원본이 변경됨\"\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 정방행렬 (예: 2x2, 3x3)\n- 가로가 긴 행렬(예: 2x3) 및 세로가 긴 행렬(예: 3x2)\n- 음수나 0을 포함한 요소\n- 입력 행렬이 비어있거나 비정상(직사각이 아님)일 때 ValueError 발생 확인\n\n**추가 개선**\n- 입력 요소 타입이 정수인지 검사하고 타입 안전성을 강화할 수 있음(속도와 절충).\n- 매우 큰 행렬에 대해서는 메모리 사용을 줄이기 위해 제너레이터 기반 스트리밍 전치(파일/스트림 입출력) 도입 가능.\n- NumPy를 사용할 수 있는 환경이라면 성능 향상을 위해 numpy.transpose 활용.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "subarray_sum_equals_k_count", "engine": "api-single", "timestamp": "2025-11-15T11:13:48.587474+00:00", "elapsed_sec": 24.626, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n누적합(prefix sum)과 해시맵을 사용해 O(n) 시간에 합이 k인 연속 부분배열의 개수를 계산합니다.\n\n**문제 분석**\n- 배열 길이 최대 10^5이므로 시간복잡도 O(n) 알고리즘 필요.\n- 음수/양수/0 모두 허용되므로 투 포인터는 불가능; 누적합과 빈도맵이 적합.\n- 빈 배열은 0을 반환(비연속/빈 부분배열은 세지 않음).\n\n**실행 계획**\n1. 누적합 cur_sum을 0으로 초기화하고, cur_sum이 등장한 횟수를 저장하는 딕셔너리 count_map을 {0:1}로 초기화(부분배열이 처음부터 시작할 경우 처리).\n2. 배열을 왼쪽에서 오른쪽으로 순회하면서 cur_sum += nums[i].\n3. cur_sum - k 가 이전에 몇 번 등장했는지 확인하면, 그만큼 끝 인덱스 i에서 합이 k인 부분배열 수가 추가된다.\n4. 현재 cur_sum의 등장 횟수를 count_map에 증가시키고, 마지막에 누적된 정답을 반환.\n\n**핵심 코드**\n```python\nfrom typing import List\nfrom collections import defaultdict\n\ndef solution(nums: List[int], k: int) -> int:\n    \"\"\"\n    합이 k인 연속 부분 배열의 개수를 반환한다.\n    시간 복잡도: O(n), 공간 복잡도: O(n) (누적합 빈도 저장용)\n    \"\"\"\n    count_map = defaultdict(int)\n    count_map[0] = 1  # 누적합이 정확히 k가 되는 부분배열(시작이 인덱스 0인 경우)을 처리하기 위해 초기화\n    cur_sum = 0\n    result = 0\n\n    for v in nums:\n        cur_sum += v\n        # cur_sum - k 가 이전에 등장한 횟수만큼 부분배열이 존재\n        result += count_map.get(cur_sum - k, 0)\n        count_map[cur_sum] += 1\n\n    return result\n\nif __name__ == \"__main__\":\n    # 간단한 단위 테스트들\n    tests = [\n        # (nums, k, expected)\n        ([1, 1, 1], 2, 2),          # [1,1] (두 위치)\n        ([1, 2, 3], 3, 2),          # [1,2], [3]\n        ([0, 0, 0], 0, 6),          # 모든 연속 부분배열 (3*4/2)\n        ([], 0, 0),                 # 빈 배열 -> 0\n        ([1, -1, 1, -1, 1], 0, 4),  # 여러 중복\n        ([3, 4, 7, 2, -3, 1, 4, 2], 7, 4),  # 혼합 테스트\n    ]\n\n    for nums, k, expected in tests:\n        got = solution(nums, k)\n        assert got == expected, f\"Fail for nums={nums}, k={k}: expected {expected}, got {got}\"\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 기본: nums=[1,1,1], k=2 -> 반환 2\n- 0 처리: nums=[0,0,0], k=0 -> 반환 6 (연속 부분배열 모두)\n- 음수 포함: nums=[1,-1,1,-1,1], k=0 -> 여러 케이스 확인\n- 경계: nums=[] (빈 리스트)와 큰 입력(길이 10^5, 임의 값)으로 성능 확인\n\n**추가 개선**\n- 메모리 개선: 값의 범위가 작거나 압축 가능한 경우 누적합 도메인을 압축해 메모리 절감 가능.\n- 병렬/스트리밍: 입력이 스트리밍될 때는 온라인 알고리즘으로 누적합과 맵 유지해 처리 가능(단, 전체 길이 대신 계속 증가).\n- 테스트 확장: 랜덤화된 대규모 테스트와 브루트포스(작은 n) 비교를 자동화해 정확성 검증 강화.\n- 타입/입력 검증 추가: 외부 입력에서 타입이 보장되지 않으면 방어적 검사(비정수 값 등) 추가 고려.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "longest_common_prefix", "engine": "api-single", "timestamp": "2025-11-15T11:14:10.324342+00:00", "elapsed_sec": 21.72, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n리스트가 비어 있으면 빈 문자열을 반환하고, 그렇지 않으면 사전식으로 가장 작은 문자열과 가장 큰 문자열만 비교하여 모든 문자열의 최장 공통 접두사를 효율적으로 찾습니다.\n\n**문제 분석**\n- 입력이 빈 리스트일 경우 빈 문자열(\"\")을 반환해야 합니다.\n- 대소문자를 구분하여 비교합니다 (case-sensitive).\n- 모든 문자열에 공통으로 나타나는 접두사 중 가장 긴 문자열을 반환해야 합니다.\n- 시간 복잡도를 줄이기 위해 전체 문자열들을 모두 비교하지 않아도 되는 최적화가 가능함.\n\n**실행 계획**\n1. 리스트가 비어 있으면 즉시 빈 문자열을 반환한다.\n2. Python의 min(), max()를 사용해 사전순으로 가장 작은 문자열과 가장 큰 문자열을 찾는다.\n3. 이 두 문자열을 문자 단위로 비교해 첫 불일치 지점까지의 부분 문자열을 반환한다.\n4. 단일 문자열 리스트와 모든 문자열이 동일한 경우도 정상 처리되도록 경계 길이를 고려한다.\n5. 간단한 단위 테스트(빈 리스트, 단일 문자열, 공통 접두사 없음, 일반 경우)를 추가하여 동작을 검증한다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(strs: List[str]) -> str:\n    \"\"\"\n    리스트 strs의 모든 문자열에 대한 최장 공통 접두사를 반환한다.\n    - 빈 리스트인 경우 \"\" 반환\n    - 대소문자 구분(민감)\n    \"\"\"\n    if not strs:\n        return \"\"\n    # 사전순으로 가장 작은 문자열과 가장 큰 문자열의 공통 접두사가\n    # 전체 리스트의 공통 접두사와 같다(비교 횟수 절감).\n    s_min = min(strs)\n    s_max = max(strs)\n    # 비교 길이는 두 문자열 중 짧은 쪽으로 제한\n    max_len = min(len(s_min), len(s_max))\n    i = 0\n    while i < max_len and s_min[i] == s_max[i]:\n        i += 1\n    return s_min[:i]\n\n\nif __name__ == \"__main__\":\n    # 간단한 테스트 가이드 (출력 확인용)\n    tests = [\n        ([], \"\"),  # 빈 리스트\n        ([\"single\"], \"single\"),  # 단일 문자열\n        ([\"flower\", \"flow\", \"flight\"], \"fl\"),  # 일반 케이스\n        ([\"dog\", \"racecar\", \"car\"], \"\"),  # 공통 접두사 없음\n        ([\"Prefix\", \"prefix\"], \"\"),  # 대소문자 구분 (다름)\n        ([\"\", \"a\", \"ab\"], \"\"),  # 빈 문자열 포함\n        ([\"same\", \"same\", \"same\"], \"same\"),  # 모두 동일\n    ]\n\n    for inp, expected in tests:\n        result = solution(inp)\n        ok = result == expected\n        print(f\"input={inp!r}, expected={expected!r}, got={result!r} -> {'OK' if ok else 'FAIL'}\")\n```\n\n**테스트 가이드**\n- 빈 리스트: [] -> \"\" 반환.\n- 공통 접두사가 있는 경우: [\"flower\",\"flow\",\"flight\"] -> \"fl\".\n- 공통 접두사가 없는 경우: [\"dog\",\"racecar\",\"car\"] -> \"\".\n- 대소문자 민감성: [\"Prefix\",\"prefix\"] -> \"\" (첫 글자 대소문자 다름).\n\n**추가 개선**\n- 큰 입력(문자열 수 n, 평균 길이 m)에 대해 성능을 더 보장하려면 이진 탐색(길이 기반) 방식이나 트라이(Trie)를 고려할 수 있음.\n- 유니코드/정규화가 필요한 데이터(특수 문자, 결합 문자 등)는 unicodedata.normalize를 적용해 비교 안정성을 높일 수 있음.\n- 경계/무작위 입력을 위한 property-based 테스트(hypothesis)와 성능 벤치마크를 추가하면 신뢰성을 향상시킬 수 있음.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "rotate_list_right", "engine": "api-single", "timestamp": "2025-11-15T11:14:50.138068+00:00", "elapsed_sec": 39.797, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n원본 리스트를 변경하지 않고, k를 n으로 나눈 나머지만큼 오른쪽으로 회전한 새로운 리스트를 슬라이싱으로 효율적으로 생성해 반환합니다.\n\n**문제 분석**\n- nums 길이 n은 0에서 10^5, k는 0에서 10^9의 범위이므로 k를 n으로 모듈로 연산해 처리해야 합니다.\n- nums 자체는 변경하면 안 되므로 항상 새로운 리스트를 반환해야 합니다.\n- 시간 복잡도는 O(n), 추가 공간은 O(n) (새 리스트 반환)로 구현합니다.\n\n**실행 계획**\n1. n = len(nums)로 길이를 구하고 n == 0이면 빈 리스트 반환.\n2. k %= n으로 불필요한 회전을 제거.\n3. k == 0이면 nums.copy()를 반환해 원본과 다른 객체를 보장.\n4. 그 외에는 슬라이싱으로 nums[-k:] + nums[:-k]를 만들어 반환(파이썬에서 슬라이스는 새 리스트를 만듦).\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int], k: int) -> List[int]:\n    \"\"\"\n    nums를 오른쪽으로 k칸 회전한 새로운 리스트를 반환합니다.\n    원본 nums는 변경하지 않습니다.\n\n    시간복잡도: O(n), 추가공간: O(n)\n    \"\"\"\n    n = len(nums)\n    if n == 0:\n        return []\n    # k를 n으로 모듈로 연산하여 불필요한 회전 제거\n    k = k % n\n    if k == 0:\n        # 같은 내용의 새로운 리스트 반환\n        return nums.copy()\n    # 오른쪽 k칸은 뒤에서 k개를 앞에 붙이는 것과 동일\n    return nums[-k:] + nums[:-k]\n\n\nif __name__ == \"__main__\":\n    # 기본 동작 검사\n    assert solution([], 5) == []\n    assert solution([1, 2, 3, 4, 5], 2) == [4, 5, 1, 2, 3]\n    assert solution([1, 2, 3], 3) == [1, 2, 3]      # k % n == 0\n    assert solution([1, 2, 3], 4) == [3, 1, 2]      # 4 % 3 == 1\n    # 큰 k 값도 처리 (동일한 결과 확인)\n    base = list(range(10))\n    assert solution(base, 10**9) == solution(base, (10**9) % 10)\n    print(\"All tests passed.\")\n```\n\n**테스트 가이드**\n- 빈 리스트: solution([], any_k) -> []\n- k가 n의 배수인 경우: 원본과 같은 내용의 새로운 리스트가 반환되는지 확인\n- k > n: k % n 만큼 회전되는지 (예: n=3, k=4 -> k% n =1)\n- 큰 n(예: 10^5)에서도 성능(시간/메모리) 관찰\n\n**추가 개선**\n- 입력이 매우 큰 경우(메모리 제약) 원본을 변경해도 되는 조건이 허용되면 O(1) 추가공간으로 in-place 회전(세 번 reverse 기법)을 제공하는 별도 함수 추가.\n- 타입/값 검증(예: k 음수 허용 시 왼쪽 회전 처리)을 추가하여 범용성 확장.\n- 반복적 테스트를 위한 벤치마크(시간, 메모리 프로파일) 스크립트 추가로 성능 안정성 검증.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "char_frequency_sort", "engine": "api-single", "timestamp": "2025-11-15T11:15:16.070061+00:00", "elapsed_sec": 25.914, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/char_frequency_sort.py\", line 59, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/char_frequency_sort.py\", line 47, in main\n    raise AssertionError(\nAssertionError: s='tree', expected 'eetr', got 'eert'", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n문자별 등장 횟수를 세어 빈도 내림차순으로 정렬하고(동률은 문자 코드 오름차순), 각 문자를 그 횟수만큼 반복해 연결한 문자열을 반환합니다.\n\n**문제 분석**\n- 입력 문자열 s의 각 문자를 세어야 한다.\n- 정렬 기준: 빈도 내림차순, 빈도 같으면 문자 코드(Unicode 코드포인트) 오름차순.\n- 출력은 정렬된 문자들을 각 문자 횟수만큼 반복해 이어붙인 문자열이어야 한다.\n- 빈 문자열 및 비 ASCII 문자도 처리 가능해야 한다.\n\n**실행 계획**\n1. collections.Counter 또는 dict로 각 문자별 빈도 계산.\n2. (문자, 빈도) 쌍을 빈도 내림차순, 문자 코드 오름차순으로 정렬: key = (-freq, ord(char)).\n3. 정렬된 쌍을 순회하며 문자 * 빈도를 이어붙여 결과 문자열 생성.\n4. 함수와 간단한 테스트를 포함해 모듈처럼 실행 가능하게 구현.\n\n**핵심 코드**\n```python\nfrom typing import Dict\nfrom collections import Counter\n\ndef solution(s: str) -> str:\n    \"\"\"\n    문자열 s의 문자를 빈도 내림차순으로 정렬하여 반환.\n    빈도가 같은 문자는 문자 코드(Unicode code point) 오름차순으로 정렬한다.\n    \"\"\"\n    if not s:\n        return \"\"\n    freq: Dict[str, int] = Counter(s)\n    # 정렬: 빈도 내림차순, 문자 코드 오름차순\n    items = sorted(freq.items(), key=lambda kv: (-kv[1], ord(kv[0])))\n    # 각 문자별로 빈도만큼 반복해서 이어붙임\n    result_parts = [char * count for char, count in items]\n    return \"\".join(result_parts)\n\nif __name__ == \"__main__\":\n    # 간단한 런타임 테스트 출력\n    tests = [\n        (\"tree\", \"eert\"),      # e:2, r:1, t:1 -> freq desc, r < t -> r before t => \"eert\"\n        (\"cccaaa\", \"aaaccc\"),  # c:3, a:3 -> same freq, 'a' < 'c' => \"aaaccc\"\n        (\"Aabb\", \"bbAa\"),      # b:2, A:1, a:1 -> 'A' (65) < 'a' (97) => \"bbAa\"\n        (\"\", \"\"),              # empty\n        (\"가나가다\", \"가가나다\"), # Unicode test: '가':2, '나':1, '다':1 -> 나<다 by code? depends, but stable by ord\n    ]\n    for inp, expected in tests:\n        out = solution(inp)\n        print(f\"input: {inp!r} -> output: {out!r}  expected (one valid): {expected!r}\")\n```\n\n**테스트 가이드**\n- 기본: \"tree\" -> \"eert\" (e 두 개 먼저, r과 t는 코드 오름차순으로 r이 먼저).\n- 동일 빈도 다수 문자: \"cccaaa\" -> \"aaaccc\" (동일 빈도면 문자 코드 오름차순).\n- 대소문자 혼합: \"Aabb\" -> \"bbAa\" (문자 코드에 따라 대문자·소문자 구분됨).\n- 빈 입력과 비 ASCII 문자(예: 한글)로 정상 동작 확인.\n\n**추가 개선**\n- 안정성: 정렬 키 계산 시 ord 호출 비용을 줄이려면 미리 (char, ord(char))를 계산해 캐싱할 수 있음.\n- 성능: 매우 큰 문자열에서 메모리 사용을 줄이려면 결과를 리스트 대신 io.StringIO로 점진적으로 작성하거나 제너레이터로 청크를 방출할 수 있음.\n- 확장: 유니코드 규칙(예: 사용자 지정 문자 순서)을 적용해야 한다면, 비교용 순위 맵을 받아 정렬 키로 사용하도록 인터페이스를 확장할 수 있음.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "num_islands", "engine": "api-single", "timestamp": "2025-11-15T11:16:01.108255+00:00", "elapsed_sec": 45.02, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/num_islands.py\", line 61, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/num_islands.py\", line 53, in main\n    raise AssertionError(f\"grid={grid!r}, expected {expected}, got {result!r}\")\nAssertionError: grid=[['1', '1', '0', '0'], ['1', '0', '0', '1'], ['0', '0', '1', '1']], expected 3, got 2", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nBFS로 방문한 '1'을 추적해 상하좌우 연결 요소(섬)의 수를 세어 반환합니다.\n\n**문제 분석**\n- 입력은 m x n 2차원 리스트이며 각 원소는 문자 '0' 또는 '1'입니다.\n- 상하좌우(대각선 제외)로 연결된 '1' 묶음을 하나의 섬으로 본다.\n- 빈 그리드나 빈 행에 대해 0을 반환해야 한다.\n- 시간 복잡도 O(m*n), 공간 복잡도 최악 O(m*n) (visited 저장)로 구현한다.\n\n**실행 계획**\n1. 입력 검증: grid가 비었거나 행 길이가 0이면 0 반환.\n2. 방문 체크용 set visited 생성 (튜플 좌표 저장)으로 입력을 변경하지 않음.\n3. 모든 셀을 순회하며 '1'이고 방문되지 않은 경우 BFS 시작 — 큐에 넣고 주변(4방향)을 반복 방문 처리.\n4. BFS로 연결된 모든 '1'를 visited에 추가하면 섬 하나를 완전히 탐색한 것이므로 카운트 증가.\n5. 전체 순회 후 카운트 반환.\n\n**핵심 코드**\n```python\nfrom collections import deque\nfrom typing import List, Tuple\n\ndef solution(grid: List[List[str]]) -> int:\n    \"\"\"\n    grid: m x n 2D list of '0'/'1' strings\n    returns: number of islands (connected components of '1' using 4-directional adjacency)\n    \"\"\"\n    if not grid or not grid[0]:\n        return 0\n\n    m = len(grid)\n    n = len(grid[0])\n    visited = set()  # set[tuple[int,int]]\n    islands = 0\n\n    def in_bounds(r: int, c: int) -> bool:\n        return 0 <= r < m and 0 <= c < n\n\n    directions: List[Tuple[int, int]] = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    for r in range(m):\n        for c in range(n):\n            if grid[r][c] != '1' or (r, c) in visited:\n                continue\n\n            # New island found, run BFS to mark all connected '1's\n            islands += 1\n            dq = deque()\n            dq.append((r, c))\n            visited.add((r, c))\n\n            while dq:\n                cr, cc = dq.popleft()\n                for dr, dc in directions:\n                    nr, nc = cr + dr, cc + dc\n                    if not in_bounds(nr, nc):\n                        continue\n                    if grid[nr][nc] != '1' or (nr, nc) in visited:\n                        continue\n                    visited.add((nr, nc))\n                    dq.append((nr, nc))\n\n    return islands\n```\n\n**테스트 가이드**\n- 단일 섬: [[\"1\",\"1\"],[\"1\",\"0\"]] → 1\n- 분리된 섬들: [[\"1\",\"0\",\"1\"],[\"0\",\"0\",\"0\"],[\"1\",\"0\",\"1\"]] → 4 (대각선은 연결 아님)\n- 빈 입력: [] 또는 [[]] → 0\n- 큰 연결 섬(스트레이트 라인): 1x1000 row of '1' → 1\n\n**추가 개선**\n- 메모리 최적화: 입력을 파괴해도 되는 경우 visited 대신 grid에 '1'을 '0'으로 덮어쓰면 추가 메모리 절약 가능.\n- 다른 접근: Union-Find(Disjoint Set)를 사용하면 동적 연결/분할 쿼리를 처리하기 쉬움(여러번 질의 시 유리).\n- 성능 테스트/검증: 랜덤 큰 그리드를 생성해 시간/메모리 프로파일링을 수행하고, 재귀 DFS 사용 시 재귀 깊이 문제를 방지하기 위한 테스트 추가.\n- 병렬화: 매우 큰 그리드를 블록 단위로 분할해 병렬 탐색 후 경계 병합 전략을 적용할 수 있음.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "longest_increasing_subarray", "engine": "api-single", "timestamp": "2025-11-15T11:16:24.987850+00:00", "elapsed_sec": 23.863, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n한 번의 선형 순회로 현재 증가 부분 배열 길이를 유지·갱신하여 비어 있을 때 0을 반환하는 O(n), O(1) 알고리즘으로 최장 연속 증가 부분 배열 길이를 구합니다.\n\n**문제 분석**\n- 입력이 빈 리스트면 0을 반환해야 함.\n- 연속(인접)한 원소들로 이루어진 엄밀한(>) 증가 부분 배열을 고려함.\n- 길이 1도 유효하므로 비어 있지 않으면 최소값은 1.\n- 시간복잡도는 O(n), 추가 메모리는 O(1)이 바람직함.\n\n**실행 계획**\n1. 입력이 비어 있는지 바로 검사하고 0 반환.\n2. 첫 원소를 시작으로 현재 증가 길이(current_len)를 1로 초기화하고, 최댓값(max_len)도 1로 초기화.\n3. 두 번째 원소부터 끝까지 순회하면서 이전 원소보다 크면 current_len 증가, 그렇지 않으면 current_len을 1로 재설정.\n4. 각 단계에서 max_len을 갱신하고 순회가 끝나면 max_len 반환.\n5. 간단한 단위 테스트(경계/일반/동일값)를 포함하여 동작을 검증.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int]) -> int:\n    \"\"\"\n    연속된 엄밀히 증가하는 부분 배열(subarray) 중 최대 길이를 반환.\n    - 빈 리스트면 0 반환.\n    - 길이 1도 유효.\n    \"\"\"\n    if not nums:\n        return 0\n\n    max_len = 1\n    current_len = 1\n\n    for i in range(1, len(nums)):\n        if nums[i] > nums[i - 1]:\n            current_len += 1\n            if current_len > max_len:\n                max_len = current_len\n        else:\n            current_len = 1\n\n    return max_len\n\n\n# 간단한 자체 검증용 테스트 실행\nif __name__ == \"__main__\":\n    tests = [\n        ([], 0),\n        ([1], 1),\n        ([1, 2, 3, 4], 4),\n        ([4, 3, 2, 1], 1),\n        ([1, 2, 1, 2, 3], 3),\n        ([1, 1, 1, 1], 1),\n        ([1, 2, 2, 3, 4], 3),  # (2,3,4)\n        ([5, 6, 7, 1, 2, 3, 4, 0], 4),\n        ([1, 3, 5, 4, 6, 8, 7, 9, 10], 3)  # (4,6,8) or (7,9,10) -> length 3\n    ]\n\n    all_ok = True\n    for inp, expected in tests:\n        out = solution(inp)\n        ok = out == expected\n        print(f\"input={inp} expected={expected} got={out} -> {'OK' if ok else 'FAIL'}\")\n        all_ok = all_ok and ok\n\n    if all_ok:\n        print(\"모든 테스트 통과\")\n    else:\n        print(\"테스트 실패 있음\")\n```\n\n**테스트 가이드**\n- 빈 리스트: [] -> 0.\n- 완전 증가: [1,2,3,4] -> 4.\n- 감소 또는 동일값만: [3,2,1] -> 1, [1,1,1] -> 1.\n- 중간에 끊기는 경우: [1,2,1,2,3] -> 3.\n\n**추가 개선**\n- 슬라이딩 윈도우나 DP로 확장하지 않아도 되지만, 연속 증가 구간의 시작/끝 인덱스를 같이 반환하도록 확장하면 구간을 바로 사용할 수 있음.\n- 대규모 스트림(무한/부분 입력) 처리 시 현재 길이와 최댓값만 유지하면 온라인으로 처리 가능 — 함수형으로 변경하거나 제너레이터와 결합해 사용.\n- 성능/정확성 자동화를 위해 PyTest 기반의 더 많은 랜덤/경계 케이스(중복, 음수, 큰 값)를 추가한 유닛 테스트를 권장.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "edit_distance", "engine": "api-single", "timestamp": "2025-11-15T11:16:50.949174+00:00", "elapsed_sec": 25.945, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n공간 최적화된 동적 계획법(두 행만 유지)으로 두 문자열 사이의 Levenshtein 거리(삽입/삭제/치환 비용 1)를 계산합니다.\n\n**문제 분석**\n- 허용 연산: 삽입, 삭제, 치환, 각 비용 1.\n- 빈 문자열 포함 모든 길이 조합을 지원해야 함.\n- 메모리를 줄이기 위해 전체 (n+1)*(m+1) 행렬 대신 O(min(n,m)) 공간을 사용.\n- 시간 복잡도는 O(n*m) (n, m는 두 문자열 길이).\n\n**실행 계획**\n1. 두 문자열 중 더 짧은 것을 내부 루프(열)로 사용해 공간을 최적화한다.\n2. 이전 행(prev)과 현재 행(curr)만을 유지하여 DP 전이식을 적용한다.\n3. 초기화: prev[j] = j (빈 문자열에서 짧은 문자열까지의 거리).\n4. 각 문자에 대해 삽입/삭제/치환 비용을 계산하여 curr[j] 갱신, 루프가 끝나면 prev=curr로 교체.\n5. 최종적으로 prev[len(short)]가 정답이 된다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(s: str, t: str) -> int:\n    \"\"\"\n    Compute the Levenshtein distance between s and t with unit cost for\n    insertion, deletion and substitution. Uses O(min(len(s), len(t))) space.\n    \"\"\"\n    # Ensure `short` is the shorter string to minimize space usage\n    if len(s) <= len(t):\n        short, long = s, t\n    else:\n        short, long = t, s\n\n    n, m = len(short), len(long)\n\n    # If the shorter string is empty, distance is length of the longer\n    if n == 0:\n        return m\n\n    # prev[j] is distance between first i-1 chars of `long` and first j chars of `short`\n    prev: List[int] = list(range(n + 1))\n\n    for i in range(1, m + 1):\n        curr: List[int] = [i] + [0] * n  # curr[0] = i (deleting i chars from long to match empty short)\n        li_char = long[i - 1]\n        for j in range(1, n + 1):\n            cost = 0 if li_char == short[j - 1] else 1\n            # operations:\n            # prev[j] + 1: delete long[i-1] (or insert into short)\n            # curr[j-1] + 1: insert long[i-1] into short (or delete from short)\n            # prev[j-1] + cost: substitute or match\n            deletion = prev[j] + 1\n            insertion = curr[j - 1] + 1\n            substitution = prev[j - 1] + cost\n            curr[j] = min(deletion, insertion, substitution)\n        prev = curr\n\n    return prev[n]\n\n# Optional simple tests when run as script\nif __name__ == \"__main__\":\n    tests = [\n        (\"kitten\", \"sitting\", 3),\n        (\"flaw\", \"lawn\", 2),\n        (\"\", \"\", 0),\n        (\"\", \"abc\", 3),\n        (\"abc\", \"\", 3),\n        (\"abc\", \"abc\", 0),\n        (\"abc\", \"axc\", 1),\n    ]\n    for a, b, expected in tests:\n        got = solution(a, b)\n        print(f\"solution({a!r}, {b!r}) = {got} (expected {expected})\")\n```\n\n**테스트 가이드**\n- 기본 비교: solution(\"kitten\", \"sitting\") → 3\n- 동일/빈 문자열: solution(\"\", \"\") → 0, solution(\"\", \"abc\") → 3\n- 단일 치환: solution(\"abc\", \"axc\") → 1\n- 교체와 삽입 혼합: solution(\"flaw\", \"lawn\") → 2\n\n**추가 개선**\n- 시간 최적화가 필요하면 C 확장 또는 Cython으로 핵심 루프를 구현.\n- 메모리-추적 기능 추가: 최소 편집 경로(연산 시퀀스)를 복원하도록 부모 포인터 또는 히스토리 저장 기능을 옵션으로 제공.\n- 대량 문자열 비교용 병렬화/벡터화(NumPy) 또는 블록 단위 처리 연구.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "word_break", "engine": "api-single", "timestamp": "2025-11-15T11:17:19.240029+00:00", "elapsed_sec": 28.274, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n동적 계획법(DP)을 사용해 가능한 분할 위치를 표기하고 사전 단어 길이로만 검사하여 문자열을 완전히 분해할 수 있는지 판별합니다.\n\n**문제 분석**\n- 각 단어는 여러 번 사용 가능하며 공백 없이 이어붙여 s를 정확히 만들어야 함.\n- 빈 문자열은 항상 True(아무 단어도 필요 없음), 빈 사전은 s가 빈 문자열일 때만 True.\n- 효율성을 위해 단어들을 집합으로 변환하고 단어 길이 집합을 사용해 검사 범위를 제한함.\n- 시간복잡도는 O(n * k) (n = len(s), k = 서로 다른 단어 길이 수) 수준으로 동작.\n\n**실행 계획**\n1. word_dict를 집합으로 변환하고 가능한 단어 길이 집합 및 최댓값을 계산한다.\n2. 길이 n+1의 불리언 DP 배열 dp를 만들고 dp[0]=True로 초기화한다.\n3. 왼쪽에서 오른쪽으로 시작 인덱스 i를 순회하며 dp[i]가 True인 경우 가능한 단어 길이만 검사해 s[i:i+len]이 단어 집합에 있는지 확인한다.\n4. 일치하면 dp[end]=True로 설정하고 end==n이면 바로 True 반환(조기 종료). 전체 순회 후 dp[n] 반환.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(s: str, word_dict: List[str]) -> bool:\n    \"\"\"\n    문자열 s가 word_dict의 단어들로 공백 없이 정확히 분해 가능한지 반환.\n    \"\"\"\n    n = len(s)\n    # 빠른 처리: 빈 문자열은 True, 빈 사전은 s가 비어있을 때만 True\n    if n == 0:\n        return True\n    if not word_dict:\n        return False\n\n    words = set(word_dict)\n    lengths = sorted({len(w) for w in words})\n    dp = [False] * (n + 1)\n    dp[0] = True\n\n    for i in range(n):\n        if not dp[i]:\n            continue\n        # 가능한 단어 길이만 검사 (길이가 남은 길이를 넘으면 브레이크)\n        for l in lengths:\n            end = i + l\n            if end > n:\n                break\n            if not dp[end] and s[i:end] in words:\n                dp[end] = True\n                if end == n:\n                    return True\n    return dp[n]\n\nif __name__ == \"__main__\":\n    # 간단한 테스트 케이스\n    tests = [\n        (\"leetcode\", [\"leet\", \"code\"], True),\n        (\"applepenapple\", [\"apple\", \"pen\"], True),\n        (\"catsandog\", [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"], False),\n        (\"\", [], True),\n        (\"a\", [], False),\n        (\"aaaa\", [\"a\", \"aa\"], True),\n    ]\n    for s, wdict, expected in tests:\n        result = solution(s, wdict)\n        print(f\"solution({s!r}, {wdict}) -> {result} (expected: {expected})\")\n        assert result == expected\n```\n\n**테스트 가이드**\n- 일반: s=\"leetcode\", word_dict=[\"leet\",\"code\"] → True\n- 여러 번 사용: s=\"applepenapple\", word_dict=[\"apple\",\"pen\"] → True\n- 불가능한 경우: s=\"catsandog\", 적절한 단어들로 분해 불가 → False\n- 엣지케이스: s=\"\", word_dict=[] → True; s non-empty, word_dict=[] → False\n\n**추가 개선**\n- Trie(접두사 트리)로 검사하면 접두사 탐색 비용을 줄일 수 있어 일부 입력에서 더 빠르게 동작.\n- DFS + 메모이제이션(탑다운)으로도 구현 가능하며, 많은 중복 탐색이 있을 때 메모이제이션으로 최적화.\n- max_word_len을 사용해 더 강하게 가지치기해 불필요한 길이 검사 줄이기 및 bitset을 사용한 dp 최적화 고려.\n- 대형 입력에 대해서는 시간/메모리 스트레스 테스트 케이스를 추가하고 성능 프로파일링 수행.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "max_subarray_sum", "engine": "api-single", "timestamp": "2025-11-15T11:17:44.127598+00:00", "elapsed_sec": 24.871, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/max_subarray_sum.py\", line 46, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/max_subarray_sum.py\", line 33, in main\n    func = load_solution(submission)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/root/ap/benchmarks/algorithm_test/max_subarray_sum.py\", line 20, in load_solution\n    spec.loader.exec_module(module)  # type: ignore[arg-type]\n    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"<frozen importlib._bootstrap_external>\", line 991, in exec_module\n  File \"<frozen importlib._bootstrap_external>\", line 1129, in get_code\n  File \"<frozen importlib._bootstrap_external>\", line 1059, in source_to_code\n  File \"<frozen importlib._bootstrap>\", line 488, in _call_with_frames_removed\n  File \"/tmp/bench-submission-ztvmtkh5/submission.py\", line 27\n    ([−2, −3, −1, −4], -1),  # all negative\n      ^\nSyntaxError: invalid character '−' (U+2212)", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nKadane 알고리즘을 사용해 선형 시간과 상수 공간으로 연속 부분 배열의 최대 합을 계산합니다.\n\n**문제 분석**\n- 입력 nums의 길이는 1 이상이며 모든 원소가 음수일 수도 있습니다.\n- 연속된 하나 이상의 원소들로 구성된 부분 배열의 합 중 최댓값을 반환해야 합니다.\n- 시간복잡도 O(n), 추가 공간 O(1)으로 해결 가능합니다.\n\n**실행 계획**\n1. 첫 원소로 초기화하여 모든-음수 케이스도 올바르게 처리하도록 설정합니다.\n2. 현재 위치에서 끝나는 최대 합(max_ending_here)을 전 요소를 이용해 갱신합니다: max(x, max_ending_here + x).\n3. 전역 최대(max_so_far)를 갱신하면서 배열을 한 번 순회합니다.\n4. 결과로 max_so_far를 반환하고, 간단한 단위 테스트로 검증합니다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(nums: List[int]) -> int:\n    \"\"\"\n    연속 부분 배열의 최대 합을 반환합니다 (Kadane 알고리즘).\n    nums는 비어있지 않음을 전제로 합니다.\n    시간복잡도: O(n), 추가공간: O(1)\n    \"\"\"\n    if not nums:\n        raise ValueError(\"nums must contain at least one element\")\n\n    max_ending_here = nums[0]\n    max_so_far = nums[0]\n\n    for x in nums[1:]:\n        # 현재 위치에서 끝나는 최대 합: 새로 시작하거나 기존에 이어붙이거나\n        max_ending_here = x if x > max_ending_here + x else max_ending_here + x\n        # 전체 최대 갱신\n        if max_ending_here > max_so_far:\n            max_so_far = max_ending_here\n\n    return max_so_far\n\n# 간단한 자체 검증 (스크립트로 실행할 때만 동작)\nif __name__ == \"__main__\":\n    tests = [\n        ([−2, −3, −1, −4], -1),  # all negative\n        ([−2, 1, −3, 4, −1, 2, 1, −5, 4], 6),  # subarray [4, -1, 2, 1]\n        ([1, 2, 3, 4], 10),  # entire array\n        ([5], 5),  # single element\n    ]\n\n    for idx, (inp, expected) in enumerate(tests, 1):\n        res = solution(inp)\n        assert res == expected, f\"Test {idx} failed: got {res}, expected {expected}\"\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 모든 수가 음수인 경우: nums = [-5, -2, -3] → 반환 -2\n- 섞인 값의 경우: nums = [-2,1,-3,4,-1,2,1,-5,4] → 반환 6\n- 모든 양수인 경우: nums = [1,2,3] → 반환 6\n\n**추가 개선**\n- 옵션 파라미터로 최대합을 만드는 부분배열의 시작-종료 인덱스를 함께 반환하도록 확장하면 디버깅/응용에 유용합니다.\n- 입력이 매우 큰 경우(예: 스트리밍/제너레이터)에도 동작하도록 제너레이터 지원 버전을 제공하면 메모리 효율적입니다.\n- 고급 검증을 위해 랜덤 테스트와 가설 기반(property-based) 테스트를 추가하여 경계 케이스를 찾습니다.\n- NumPy를 이용해 벡터화하거나 병렬 분할 정복 방식으로 매우 큰 입력에 대한 성능 최적화를 고려할 수 있습니다.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "shortest_path_unweighted", "engine": "api-single", "timestamp": "2025-11-15T11:18:13.340648+00:00", "elapsed_sec": 29.196, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n시작 노드 유효성을 검사한 뒤 너비우선탐색(BFS)으로 각 노드까지의 최소 간선 수(거리)를 계산해 도달 가능한 노드들만 딕셔너리로 반환합니다.\n\n**문제 분석**\n- 그래프는 방향성 있는 무가중치(간선 가중치 동일)이며 모든 노드가 키로 존재한다.\n- 시작점이 그래프에 없으면 ValueError를 발생시켜야 한다.\n- 거리 정의는 간선 수(최단 경로의 간선 개수)이며 도달 불가능한 노드는 결과에 포함하지 않는다.\n- BFS가 최단 간선 수 탐색에 적합하다.\n\n**실행 계획**\n1. 시작 노드 존재 여부를 검사해 없으면 ValueError 발생.\n2. deque를 이용해 BFS 큐를 초기화하고 시작 노드의 거리를 0으로 설정.\n3. 큐에서 노드를 꺼내 인접 노드들을 방문하지 않았다면 거리를 현재 거리+1로 설정하고 큐에 추가.\n4. 모든 방문 가능한 노드를 처리한 뒤 거리 딕셔너리만 반환(도달 불가능한 노드는 포함하지 않음).\n\n**핵심 코드**\n```python\nfrom collections import deque\nfrom typing import Dict, List\n\ndef solution(graph: Dict[str, List[str]], start: str) -> Dict[str, int]:\n    \"\"\"\n    무가중치 방향 그래프 graph에서 start로부터 각 노드까지의 최단 거리(간선 수)를 계산합니다.\n    - graph: 인접 리스트, 존재하는 모든 노드가 키로 등장해야 합니다.\n    - start: 시작 노드 (graph에 없으면 ValueError 발생)\n    - 반환: start에서 도달 가능한 노드들의 거리 딕셔너리 {노드: 거리}\n    \"\"\"\n    if start not in graph:\n        raise ValueError(f\"start node '{start}' not found in graph\")\n\n    distances: Dict[str, int] = {start: 0}\n    q = deque([start])\n\n    while q:\n        u = q.popleft()\n        current_dist = distances[u]\n        # 인접 목록은 graph에 키로 항상 존재한다고 가정\n        for v in graph.get(u, []):\n            if v not in distances:\n                distances[v] = current_dist + 1\n                q.append(v)\n\n    return distances\n\n\n# 간단한 데모/자가 테스트 (모듈로 import할 때 실행되지 않음)\nif __name__ == \"__main__\":\n    g = {\n        \"A\": [\"B\", \"C\"],\n        \"B\": [\"C\", \"D\"],\n        \"C\": [\"E\"],\n        \"D\": [\"C\"],\n        \"E\": [],\n        \"F\": []  # F는 다른 노드와 연결되어 있지 않음(도달 불가)\n    }\n\n    print(solution(g, \"A\"))  # 기대: {'A':0, 'B':1, 'C':1, 'D':2, 'E':2}\n    try:\n        print(solution(g, \"Z\"))  # start 없음 -> ValueError\n    except ValueError as e:\n        print(\"ValueError:\", e)\n```\n\n**테스트 가이드**\n- 연결된 그래프: 모든 노드가 start에서 도달 가능하면 모든 노드 포함 확인.\n- 일부 비연결 노드 포함: 도달 불가능한 노드는 결과에서 빠지는지 확인 (예: 'F').\n- 싸이클 존재: 사이클이 있어도 무한루프 없이 거리 최단값을 반환하는지 확인.\n- start 미존재: start가 graph 키에 없으면 ValueError 발생 확인.\n\n**추가 개선**\n- 반환값에 거리뿐 아니라 실제 최단 경로(노드 리스트)를 함께 반환하도록 옵션 추가.\n- 그래프 입력 신뢰성 검사(이웃 노드가 graph에 키로 존재하는지 등)를 선택적 검증 모드로 추가.\n- 대규모 그래프를 위한 메모리/성능 개선(제너레이터 사용, 방문 체크 최적화) 및 타입 검사 강화.\n- 단위 테스트(PyTest) 케이스 추가로 경계 조건(빈 그래프, 단일 노드, 자기 루프 등) 자동 검증.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "meeting_rooms_min", "engine": "api-single", "timestamp": "2025-11-15T11:18:40.702727+00:00", "elapsed_sec": 27.345, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n시작 시간과 종료 시간을 각각 정렬한 뒤 두 포인터를 이용해 동시에 스윕하며 사용 중인 회의실 개수를 추적해 최소 회의실 수를 계산합니다.\n\n**문제 분석**\n- 입력은 (start, end) 튜플의 리스트이며 start < end가 보장됩니다.\n- 같은 회의실은 한 시점에 하나의 회의만 수용할 수 있으므로 시간 구간이 겹치면 별도의 회의실이 필요합니다.\n- 시작 시간이 어떤 회의의 종료 시간과 같거나 큰 경우(끝 <= 시작)에는 같은 회의실을 재사용할 수 있습니다.\n- 목표는 모든 회의를 배치하기 위한 최소 회의실 개수(동시 최대 겹침 수)를 반환하는 것임.\n\n**실행 계획**\n1. intervals가 비어 있으면 0을 반환한다.\n2. 모든 시작시간(start_times)과 종료시간(end_times)을 분리하여 각각 오름차순 정렬한다.\n3. 두 포인터 i(시작 인덱스), j(종료 인덱스)를 이용해 start_times를 순회한다.\n4. 현재 회의의 시작시간이 가장 작은 종료시간보다 크거나 같으면 기존 회의실을 재사용(종료 포인터 증가), 그렇지 않으면 새로운 회의실 필요(카운트 증가).\n5. 모든 시작시간을 처리한 후의 최대 동시 사용 회의실 수를 반환한다.\n\n**핵심 코드**\n```python\nfrom typing import List, Tuple\n\ndef solution(intervals: list[tuple[int, int]]) -> int:\n    \"\"\"\n    주어진 회의 시간(intervals)들을 모두 수용하기 위한 최소 회의실 수를 반환한다.\n    각 interval은 (start, end)로 주어지며 start < end가 보장된다.\n    시간 복잡도: O(n log n) (정렬), 추가 공간 복잡도: O(n)\n    \"\"\"\n    if not intervals:\n        return 0\n\n    # 분리 및 정렬\n    starts = sorted(start for start, end in intervals)\n    ends = sorted(end for start, end in intervals)\n\n    rooms_needed = 0\n    end_ptr = 0\n    n = len(intervals)\n\n    # 각 시작시간을 순회하며 현재 필요한 회의실 수를 계산\n    for i in range(n):\n        if starts[i] >= ends[end_ptr]:\n            # 가장 이른 종료 회의가 끝났으므로 같은 방 재사용 가능\n            end_ptr += 1\n        else:\n            # 겹침 -> 새로운 방 필요\n            rooms_needed += 1\n\n    return rooms_needed\n\n# 간단한 자체 테스트\nif __name__ == \"__main__\":\n    tests = [\n        ([], 0),\n        ([(0, 30), (5, 10), (15, 20)], 2),\n        ([(1,4),(2,5),(3,6)], 3),\n        ([(1,2),(2,3),(3,4)], 1),  # 끝이 시작과 같으면 재사용 가능\n        ([(1,10),(2,3),(3,4),(4,5),(11,12)], 2),\n        ([(0,5),(5,10),(10,15)], 1),\n    ]\n\n    for intervals, expected in tests:\n        result = solution(intervals)\n        print(f\"intervals={intervals} -> need {result} rooms (expected {expected})\")\n        assert result == expected, f\"테스트 실패: {intervals} 예상 {expected} 실제 {result}\"\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 기본 겹침 케이스: [(0,30),(5,10),(15,20)] → 결과 2\n- 전부 겹치는 케이스: [(1,4),(2,5),(3,6)] → 결과 3\n- 경계가 닿는 케이스(종료 == 시작): [(1,2),(2,3),(3,4)] → 결과 1\n- 빈 입력: [] → 결과 0\n\n**추가 개선**\n- 큰 입력에 대해 메모리 최적화를 원하면 정렬 후 포인터 방식은 그대로 유지하되 starts 또는 ends를 제자리 정렬(in-place)하여 추가 복사 최소화 가능.\n- 실시간(온라인)으로 회의가 도착하는 경우에는 min-heap으로 끝시간을 관리하는 방식이 적합(삽입/제거 O(log n)) — 동적 추가/삭제가 빈번할 때 이점.\n- 단위 테스트를 pytest로 분리하고 랜덤 스트레스 테스트(무작위 간격 생성 후 브루트포스 시뮬레이션과 비교)를 추가하여 안정성 강화.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "topological_sort", "engine": "api-single", "timestamp": "2025-11-15T11:19:10.255024+00:00", "elapsed_sec": 29.535, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n가능한 위상 정렬 중 사전순으로 가장 앞서는 순서를 얻기 위해 Kahn 알고리즘과 최소 힙(heapq)을 사용해 진입차수가 0인 노드 중 항상 사전적으로 가장 작은 노드를 선택합니다.\n\n**문제 분석**\n- 입력 graph는 각 노드의 인접 리스트를 담은 dict이며, 일부 노드는 키로 없고 인접 리스트에만 등장할 수 있음.\n- 그래프는 DAG라 가정하지만, 안전하게 결과 길이로 사이클 여부를 검증할 수 있음.\n- 요구하는 결과는 가능한 위상 정렬들 중 사전식(lexicographic)으로 가장 앞서는 순서.\n- 시간복잡도 목표: O((V+E) log V) — 진입차수 0 노드 선택을 힙으로 처리.\n\n**실행 계획**\n1. 모든 노드(딕셔너리 키와 값으로 등장하는 노드 모두)를 수집하고 각 노드의 진입차수(in-degree)를 계산한다.\n2. 진입차수가 0인 모든 노드를 최소 힙(min-heap)에 넣어 사전순으로 가장 작은 노드 먼저 선택되게 한다.\n3. 힙에서 노드를 하나씩 꺼내 결과에 추가하고 그 노드의 모든 이웃의 진입차수를 감소시켜 0이 되면 힙에 추가한다.\n4. 처리 후 결과 길이가 전체 노드 수와 같지 않으면 사이클(또는 입력 오류)이므로 예외를 던진다. 정상적이면 결과 반환.\n\n**핵심 코드**\n```python\nimport heapq\nfrom typing import Dict, List\n\ndef solution(graph: Dict[str, List[str]]) -> List[str]:\n    \"\"\"\n    DAG의 위상 정렬 결과 중 사전식으로 가장 앞서는 순서를 반환.\n    graph: 각 노드 -> 인접 리스트(문자열 노드들의 리스트)\n    \"\"\"\n    # 모든 노드 수집 (키로만 있거나 값으로만 있는 노드 포함)\n    nodes = set(graph.keys())\n    for nbrs in graph.values():\n        for v in nbrs:\n            nodes.add(v)\n\n    # 초기 진입차수 0으로 설정\n    indeg = {node: 0 for node in nodes}\n    # 진입차수 계산\n    for u, nbrs in graph.items():\n        for v in nbrs:\n            indeg[v] = indeg.get(v, 0) + 1\n\n    # 진입차수 0인 노드들을 최소 힙에 삽입(사전순 보장)\n    heap = []\n    for node, d in indeg.items():\n        if d == 0:\n            heapq.heappush(heap, node)\n\n    result = []\n    while heap:\n        u = heapq.heappop(heap)\n        result.append(u)\n        # u의 이웃들의 진입차수 감소\n        for v in graph.get(u, []):\n            indeg[v] -= 1\n            if indeg[v] == 0:\n                heapq.heappush(heap, v)\n\n    if len(result) != len(nodes):\n        raise ValueError(\"입력 그래프가 DAG가 아닙니다(사이클 존재 또는 입력 오류).\")\n\n    return result\n\n# 간단한 내부 테스트 (모듈 사용 시 자동 실행 방지)\nif __name__ == \"__main__\":\n    # 예1: 단순 체인\n    g1 = {\"a\": [\"b\"], \"b\": [\"c\"], \"c\": []}\n    assert solution(g1) == [\"a\", \"b\", \"c\"]\n\n    # 예2: 분기와 사전순 처리\n    g2 = {\"a\": [\"c\"], \"b\": [\"c\"], \"c\": [\"d\"], \"d\": []}\n    # a와 b 중 사전이 앞서는 'a'가 먼저 와야 함\n    assert solution(g2) == [\"a\", \"b\", \"c\", \"d\"]\n\n    # 예3: 값에만 존재하는 노드 포함\n    g3 = {\"x\": [\"y\"], \"z\": []}  # y는 키로 없음\n    res3 = solution(g3)\n    assert set(res3) == {\"x\", \"y\", \"z\"} and res3.index(\"x\") < res3.index(\"y\")\n\n    print(\"내부 테스트 통과\")\n```\n\n**테스트 가이드**\n- 단일 경로: {\"a\":[\"b\"], \"b\":[\"c\"], \"c\":[]} -> [\"a\",\"b\",\"c\"]\n- 분기되는 그래프에서 가능한 시작 노드 여러 개일 때 사전순 확인: {\"a\":[\"c\"], \"b\":[\"c\"], \"c\":[\"d\"], \"d\":[]} -> [\"a\",\"b\",\"c\",\"d\"]\n- 값으로만 등장하는 노드 포함: {\"x\":[\"y\"], \"z\":[]} -> x가 y보다 먼저 나오도록 검사\n- 빈 그래프: {} -> []\n\n**추가 개선**\n- 큰 그래프에서 성능 향상을 위해 노드 이름이 문자열이지만 내부적으로 정수 ID로 매핑하여 메모리/비교 비용을 줄일 수 있음.\n- 여러 가능한 사전순 최소 해가 동일할 때 결정 규칙을 바꾸고 싶다면 비교 키(예: 길이, 가중치 등)를 함께 사용하도록 힙에 (key, node) 튜플을 저장하도록 확장 가능.\n- 입력 검증 강화: 중복 간선 제거, 유효하지 않은 노드 이름(예: None) 검사, 혹은 사이클 발견 시 사이클 노드 리스트를 반환하는 기능 추가. \n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "knapsack_01_max_value", "engine": "api-single", "timestamp": "2025-11-15T11:19:45.191281+00:00", "elapsed_sec": 34.918, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n1차원 DP(무게 기준 역방향 업데이트)를 사용해 O(n * capacity) 시간·O(capacity) 공간으로 0-1 배낭의 최대 가치를 계산합니다.\n\n**문제 분석**\n- n ≤ 30, capacity ≈ 1000으로 DP 시간 복잡도 O(n * capacity)는 충분히 빠릅니다.\n- 각 물건은 0 또는 1개만 선택 가능(중복 불가)이므로 무게 기준 역방향 업데이트가 필요합니다.\n- 입력 길이 불일치나 음수 용량 같은 간단한 검증을 수행합니다.\n\n**실행 계획**\n1. 입력 유효성 검사: 길이 일치, capacity가 음수이면 0 반환.\n2. capacity+1 길이의 정수 배열 dp 초기화(모든 값 0).\n3. 각 아이템(weight, value)에 대해 무게 w를 capacity부터 weight까지 역순 반복:\n   - dp[w] = max(dp[w], dp[w - weight] + value)\n4. dp[capacity] 또는 dp 전체의 최댓값을 반환(둘은 동일 의미).\n5. 간단한 단위 테스트(몇 가지 케이스와 랜덤 비교)를 포함하여 검증.\n\n**핵심 코드**\n```python\nfrom typing import List\nimport random\n\ndef solution(weights: List[int], values: List[int], capacity: int) -> int:\n    # 기본 검증\n    if capacity <= 0:\n        return 0\n    if len(weights) != len(values):\n        raise ValueError(\"weights and values must have the same length\")\n    n = len(weights)\n    # 음수 무게나 음수 가치 허용 여부: 여기서는 음수 무게는 무의미하므로 에러 처리\n    for w in weights:\n        if w < 0:\n            raise ValueError(\"weights must be non-negative\")\n    # DP 배열: dp[w] = 최대 가치 (총 허용 무게가 w일 때)\n    dp = [0] * (capacity + 1)\n    for i in range(n):\n        wt = weights[i]\n        val = values[i]\n        if wt == 0:\n            # 무게 0의 아이템은 가치가 양수일 경우 항상 취하는 것이 유리 (단, 중복 불가)\n            # 무게 0의 아이템을 처리하려면 현재 dp에 val을 더한 값으로 갱신하되, 역방향 루프와 동일하게 처리\n            # 다만 무게가 0인 경우 역방향 루프가 의미없으므로 별도 처리\n            if val > 0:\n                for w in range(capacity, -1, -1):\n                    dp[w] += val\n            else:\n                # 가치 0 또는 음수는 무시(선택하지 않는 것이 나음)\n                pass\n            continue\n        if wt > capacity:\n            # 이 아이템은 어떤 경우에도 담을 수 없음\n            continue\n        # 0-1 knapsack: 역방향으로 갱신하여 같은 아이템을 중복 사용하지 않도록 함\n        for w in range(capacity, wt - 1, -1):\n            cand = dp[w - wt] + val\n            if cand > dp[w]:\n                dp[w] = cand\n    return dp[capacity]\n\n# 간단한 테스트 스위트\nif __name__ == \"__main__\":\n    # 예제 1\n    w1 = [3, 2, 1]\n    v1 = [5, 3, 2]\n    cap1 = 5\n    # 최적: 아이템 0(w3,v5) + 아이템1(w2,v3) => 무게5, 가치8\n    assert solution(w1, v1, cap1) == 8\n\n    # 예제 2: 모든 아이템 무게 > capacity\n    w2 = [6, 7, 8]\n    v2 = [10, 20, 30]\n    cap2 = 5\n    assert solution(w2, v2, cap2) == 0\n\n    # 예제 3: 무게 0 아이템 (가치 양수)\n    w3 = [0, 2, 3]\n    v3 = [4, 3, 5]\n    cap3 = 5\n    # 무게0 아이템을 항상 포함하면 남은 용량 5에 대해 나머지 최적 선택: 기대값 = 4 + max(3,5,3+5?) -> 4 + 8 = 12\n    assert solution(w3, v3, cap3) == 12\n\n    # 무작위 검증: 작은 n에서는 완전 탐색(브루트포스)와 비교\n    def brute(weights, values, capacity):\n        n = len(weights)\n        best = 0\n        for mask in range(1 << n):\n            tw = 0\n            tv = 0\n            ok = True\n            for i in range(n):\n                if mask >> i & 1:\n                    tw += weights[i]\n                    tv += values[i]\n                    if tw > capacity:\n                        ok = False\n                        break\n            if ok and tv > best:\n                best = tv\n        return best\n\n    for _ in range(50):\n        n = random.randint(1, 10)\n        ws = [random.randint(0, 6) for _ in range(n)]\n        vs = [random.randint(0, 10) for _ in range(n)]\n        cap = random.randint(0, 20)\n        assert solution(ws, vs, cap) == brute(ws, vs, cap)\n\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- 기본 작동: weights=[3,2,1], values=[5,3,2], capacity=5 → 결과 8\n- 불가능한 경우: 모든 아이템 무게가 capacity보다 클 때 → 결과 0\n- 무게 0 아이템 처리: 무게0, 가치양수인 아이템이 포함되어도 올바르게 반영되는지 확인\n- 랜덤 소규모 케이스를 브루트포스와 비교 검증\n\n**추가 개선**\n- n이 커지거나 capacity가 매우 클 때를 대비해 값 기준 DP 또는 meet-in-the-middle(특히 n ≤ 30일 때)로 대체 가능.\n- 음수 가치 항목(페널티)이 있을 경우 선택 안 하는 것이 유리하므로 현재 로직에서 무게 0인 음수 가치는 무시 처리했지만, 정책을 명확히 정해 처리 로직을 확장할 수 있음.\n- 성능 테스트(시간 측정)와 메모리 프로파일링 추가, 그리고 타입 검사(정수 검증) 유닛 테스트 확장.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "coin_change_min_coins", "engine": "api-single", "timestamp": "2025-11-15T11:20:08.516132+00:00", "elapsed_sec": 23.308, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n동적 계획법으로 0..amount까지 만들 수 있는 최소 동전 수를 bottom-up으로 계산해 결과를 반환합니다.\n\n**문제 분석**\n- 각 동전은 무한히 사용할 수 있으므로 동전 반복 사용을 허용한 완전 배낭(coin change) 문제입니다.\n- amount가 0이면 0을 반환해야 하고, 정확히 만들 수 없으면 -1을 반환해야 합니다.\n- coins에 0 이하 값이 포함될 수 있으니 무효한 동전값은 무시합니다.\n- 시간복잡도는 O(len(coins) * amount), 공간복잡도는 O(amount)입니다.\n\n**실행 계획**\n1. 입력 검증: amount가 0인 경우 0을 바로 반환, coins에서 양수 정수만 사용하도록 필터링.\n2. DP 배열 dp를 길이 amount+1로 만들고 dp[0]=0, 나머지는 INF(amount+1)로 초기화.\n3. 1..amount까지 순차적으로 각 금액에 대해 사용 가능한 모든 동전을 시도해 dp를 갱신.\n4. dp[amount]이 INF이면 -1 반환, 그렇지 않으면 dp[amount] 반환.\n5. 간단한 단위 테스트를 포함해 함수의 동작을 검증.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(coins: List[int], amount: int) -> int:\n    \"\"\"\n    주어진 동전들로 amount를 만드는 데 필요한 최소 동전 개수 반환.\n    만들 수 없으면 -1 반환.\n    \"\"\"\n    # 빠른 처리\n    if amount == 0:\n        return 0\n\n    # 유효한 동전만 사용 (음수나 0은 무시)\n    coins = [c for c in coins if isinstance(c, int) and c > 0]\n    if not coins:\n        return -1\n\n    INF = amount + 1  # amount보다 큰 값은 불가능 표시로 사용\n    dp = [INF] * (amount + 1)\n    dp[0] = 0\n\n    # bottom-up\n    for a in range(1, amount + 1):\n        # 각 동전에 대해 해당 금액을 만들 수 있으면 갱신\n        for c in coins:\n            if c <= a:\n                prev = dp[a - c]\n                if prev + 1 < dp[a]:\n                    dp[a] = prev + 1\n\n    return dp[amount] if dp[amount] != INF else -1\n\n\n# 간단한 테스트 헬퍼 (모듈로 사용 시 실행되지 않음)\nif __name__ == \"__main__\":\n    tests = [\n        (([1, 2, 5], 11), 3),   # 5+5+1\n        (([2], 3), -1),         # 만들 수 없음\n        (([], 0), 0),           # amount 0이면 0\n        (([0, 1], 1), 1),       # 0은 무시, 1 사용\n        (([3, 7], 5), -1),      # 만들 수 없음\n        (([5], 10), 2),         # 5+5\n    ]\n\n    for (coins, amount), expected in tests:\n        res = solution(coins, amount)\n        assert res == expected, f\"Fail for coins={coins}, amount={amount}: got {res}, want {expected}\"\n    print(\"모든 테스트 통과\")\n```\n\n**테스트 가이드**\n- coins=[1,2,5], amount=11 → 결과 3 (5+5+1)\n- coins=[2], amount=3 → 결과 -1 (정확히 만들 수 없음)\n- coins=[] 또는 coins에 유효한 동전이 없고 amount>0 → -1\n- amount=0 → 0 반환\n\n**추가 개선**\n- 동전 수가 많거나 amount가 큰 경우 메모리 최적화(예: BFS로 최단 거리 탐색) 또는 그리디-검증(특정 동전 집합에서) 기법 고려.\n- 테스트 확장: 랜덤 테스트 케이스와 brute-force(작은 amount)에 의한 교차 검증으로 신뢰성 검증.\n- 성능: coins의 정렬과 큰 동전 우선 처리로 실제 평균 성능 개선 가능(상태 공간 조기 차단).\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "longest_increasing_subsequence_length", "engine": "api-single", "timestamp": "2025-11-15T11:20:24.424126+00:00", "elapsed_sec": 15.891, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\nPatience sorting 방식(tails 배열과 이진 탐색)을 사용해 O(n log n) 시간 복잡도로 엄밀히 증가하는 최장 부분 수열(LIS)의 길이를 계산합니다.\n\n**문제 분석**\n- 입력 nums 길이는 최대 2000으로 작은 편이나, O(n log n)으로도 충분히 빠릅니다.\n- 부분 수열은 인덱스가 증가해야 하고 값은 엄밀히 증가(strictly increasing)해야 합니다.\n- 동일 값이 등장하면 길이를 늘리지 않으므로 tails 갱신에 bisect_left를 사용합니다.\n\n**실행 계획**\n1. 빈 입력 처리: nums가 비어 있으면 0 반환.\n2. tails 리스트를 유지: tails[i]는 길이가 i+1인 증가 부분 수열들 중 끝값의 최솟값.\n3. 각 숫자 x에 대해 tails에서 이진 탐색으로 첫 번째 >= x 위치를 찾아 대체(혹은 끝에 추가).\n4. 모든 숫자 처리 후 tails 길이가 LIS 길이이므로 반환.\n5. 간단한 단위 테스트(여러 케이스의 assert)를 포함해 동작 검증.\n\n**핵심 코드**\n```python\nfrom bisect import bisect_left\nfrom typing import List\n\ndef solution(nums: List[int]) -> int:\n    \"\"\"\n    엄밀히 증가하는 최장 부분 수열(LIS)의 길이를 반환합니다.\n    시간 복잡도: O(n log n), 공간 복잡도: O(n)\n    \"\"\"\n    if not nums:\n        return 0\n\n    tails: List[int] = []  # tails[i] = 최소 가능한 끝값 for 길이 i+1\n\n    for x in nums:\n        # pos: 첫 번째 요소가 x 이상인 위치 (>= x)\n        pos = bisect_left(tails, x)\n        if pos == len(tails):\n            tails.append(x)\n        else:\n            tails[pos] = x\n    return len(tails)\n\n# 간단한 런-타임 테스트 (모듈 직접 실행 시)\nif __name__ == \"__main__\":\n    tests = [\n        ([], 0),\n        ([1], 1),\n        ([1, 2, 3, 4, 5], 5),\n        ([5, 4, 3, 2, 1], 1),\n        ([2, 2, 2, 2], 1),\n        ([10,9,2,5,3,7,101,18], 4),  # 예: [2,3,7,101]\n        ([0,1,0,3,2,3], 4),         # 예: [0,1,2,3]\n        ([3,5,6,2,5,4,19,5,6,7,12], 6), # 예 하나: [3,5,6,19] 등 (최장 길이 6)\n    ]\n\n    for arr, expected in tests:\n        res = solution(arr)\n        assert res == expected, f\"Failed for {arr}: expected {expected}, got {res}\"\n    print(\"All tests passed.\")\n```\n\n**테스트 가이드**\n- 빈 리스트, 단일 원소 리스트로 기본 동작 확인.\n- 정렬된 증가/감소 리스트로 경계값 확인.\n- 반복되는 값(예: [2,2,2])와 혼합 값(예: [10,9,2,5,3,7,101,18])으로 정확성 검증.\n- 랜덤 배열(길이 100~200, 중복 포함)으로 속도 및 안정성 확인.\n\n**추가 개선**\n- LIS의 실제 요소들을 복원(reconstruct)하는 기능 추가: predecessor 인덱스와 길이별 마지막 인덱스를 기록하면 O(n log n)으로 경로 복원 가능.\n- O(n^2) DP 버전을 옵션으로 제공해 문제 크기나 디버깅 목적에서 비교 가능하게 구현.\n- 유닛 테스트 프레임워크(pytest) 기반의 더 광범위한 케이스(랜덤, 경계값, 성능) 추가 권장.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "min_window_substring", "engine": "api-single", "timestamp": "2025-11-15T11:20:46.743665+00:00", "elapsed_sec": 22.302, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n슬라이딩 윈도우로 좌우 포인터를 이동하면서 필요 문자 카운트를 유지해 유효 윈도우를 축소/확장하여 최소 길이의 부분 문자열을 찾습니다.\n\n**문제 분석**\n- t에 등장하는 각 문자의 빈도(중복 포함)를 정확히 만족해야 함.\n- 여러 정답이 있을 때는 길이가 짧은 것 우선, 길이 같으면 시작 인덱스가 작은 것을 반환.\n- s나 t가 빈 문자열이거나 t의 길이가 s보다 길면 빈 문자열을 반환.\n\n**실행 계획**\n1. t의 문자별 필요 개수를 Counter로 계산하고, 필요한 서로 다른 문자 수(required)를 구합니다.\n2. 두 포인터 l(왼쪽), r(오른쪽)를 이용해 오른쪽으로 확장하면서 현재 윈도우의 문자 카운트를 갱신하고, 요구를 만족하는 문자 수(formed)를 추적합니다.\n3. formed == required이면 왼쪽 포인터를 가능한 한 오른쪽으로 옮겨 윈도우를 축소하면서 최소 길이 및 시작 인덱스를 갱신합니다(같은 길이일 때는 기존 것을 유지하여 시작 인덱스가 작은 것을 보장).\n4. 전체 문자열을 탐색한 후 최소 윈도우를 반환. 경계 케이스(빈 t 등)는 초기 처리.\n\n**핵심 코드**\n```python\nfrom collections import Counter\nfrom typing import Dict\n\ndef solution(s: str, t: str) -> str:\n    \"\"\"\n    최소 윈도우 부분 문자열: s에서 t의 모든 문자를 포함하는 가장 짧은 부분 문자열을 반환.\n    요구되는 문자의 빈도를 모두 만족해야 한다. 없으면 빈 문자열 반환.\n    \"\"\"\n    if not t or not s or len(t) > len(s):\n        return \"\"\n\n    need: Dict[str, int] = Counter(t)\n    required = len(need)  # 만족해야 하는 서로 다른 문자 수\n\n    # 현재 윈도우의 문자 카운트와 formed(요구를 만족한 문자 종류 수)\n    window: Dict[str, int] = {}\n    formed = 0\n\n    l = 0\n    min_len = float(\"inf\")\n    min_start = 0\n\n    # 오른쪽 포인터를 이동하며 윈도우 확장\n    for r, ch in enumerate(s):\n        window[ch] = window.get(ch, 0) + 1\n\n        # 이 문자가 필요했고, 필요한 개수에 도달했을 때 formed 증가\n        if ch in need and window[ch] == need[ch]:\n            formed += 1\n\n        # 현재 윈도우가 모든 요구를 만족하면 좌측을 옮겨 최소화 시도\n        while l <= r and formed == required:\n            cur_len = r - l + 1\n            # 길이가 더 짧을 때만 갱신하여 같은 길이일 경우 먼저 발견된(작은 start) 것을 유지\n            if cur_len < min_len:\n                min_len = cur_len\n                min_start = l\n\n            # 왼쪽 문자 제거 시도\n            left_char = s[l]\n            window[left_char] -= 1\n            if left_char in need and window[left_char] < need[left_char]:\n                formed -= 1\n            l += 1\n\n    if min_len == float(\"inf\"):\n        return \"\"\n    return s[min_start:min_start + min_len]\n\n\nif __name__ == \"__main__\":\n    # 간단한 대표 테스트들\n    cases = [\n        (\"ADOBECODEBANC\", \"ABC\", \"BANC\"),\n        (\"a\", \"aa\", \"\"),\n        (\"a\", \"a\", \"a\"),\n        (\"ab\", \"b\", \"b\"),\n        (\"aa\", \"aa\", \"aa\"),\n        (\"\", \"a\", \"\"),\n        (\"abdabca\", \"abc\", \"abc\"),  # 여러 후보가 있을 때 길이 동일하면 선행 인덱스 선택\n    ]\n    for s, t, expected in cases:\n        out = solution(s, t)\n        print(f\"s={s!r}, t={t!r} -> {out!r} (expected {expected!r})\")\n```\n\n**테스트 가이드**\n- 표준 예시: s=\"ADOBECODEBANC\", t=\"ABC\" -> \"BANC\"\n- 불가능한 경우: s=\"a\", t=\"aa\" -> 빈 문자열\n- 단일 문자 매칭: s=\"a\", t=\"a\" -> \"a\"\n- 같은 길이 후보의 선행 선택 확인: s=\"abdabca\", t=\"abc\" -> 왼쪽에서 처음 등장하는 \"abc\"\n\n**추가 개선**\n- 성능: s에서 need에 없는 문자들을 미리 필터링한 인덱 리스트만 순회하면 상수 요인이 개선됩니다(특히 문자셋이 큰 경우 유리).\n- 테스트: 임의 길이의 랜덤 문자열과 브루트포스(모든 부분 문자열 검사)로 결과 비교하는 단위 테스트를 추가해 신뢰도를 높일 수 있습니다.\n- 확장: 멀티바이트/유니코드 문자 집합에도 이미 동작하나, 메모리 제약 환경에서는 sliding-window 인덱 필터링과 함께 제약 기반 스트리밍 처리 구현을 고려하세요.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "max_rectangle_in_histogram", "engine": "api-single", "timestamp": "2025-11-15T11:21:14.842501+00:00", "elapsed_sec": 28.082, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n스택에 인덱스를 저장해 각 바가 최소 높이가 되는 범위를 빠르게 계산하는 단일 통과 O(n) 알고리즘을 구현합니다.\n\n**문제 분석**\n- 입력 heights는 각 막대의 높이 리스트이며 연속한 막대들을 선택해 만들 수 있는 직사각형의 최대 넓이를 구해야 합니다.\n- 목표 시간복잡도는 O(n), 공간복잡도는 O(n) 이하(스택 사용).\n- 높이가 같은 막대를 적절히 처리해야 하며 빈 리스트일 때 0을 반환해야 합니다.\n\n**실행 계획**\n1. 인덱스 스택을 사용하되 바닥에 sentinel인 -1을 넣어 경계 처리를 단순화한다.\n2. 각 인덱이를 순회하며 현재 높이보다 큰 높이를 스택에서 팝하여 그 막대가 최대 높이인 구간의 너비를 계산한다.\n3. 순회가 끝난 뒤 남은 스택 원소들도 동일한 방식으로 처리하여 모든 경우를 고려한다.\n4. 경계/빈 리스트/단일 원소 등의 예외 케이스를 테스트 코드로 검증한다.\n\n**핵심 코드**\n```python\nfrom typing import List\n\ndef solution(heights: List[int]) -> int:\n    \"\"\"\n    히스토그램에서 가장 큰 직사각형 넓이를 반환.\n    시간복잡도: O(n), 공간복잡도: O(n)\n    \"\"\"\n    if not heights:\n        return 0\n\n    # 간단한 입력 검증 (음수 높이는 문제 정의에 따라 다를 수 있음)\n    # for h in heights:\n    #     if h < 0:\n    #         raise ValueError(\"heights must be non-negative\")\n\n    max_area = 0\n    stack = [-1]  # sentinel 인덱스: 넓이 계산을 단순화\n\n    # 순회하면서 현재 막대보다 높은 막대가 있으면 팝하여 면적 계산\n    for i, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] > h:\n            height = heights[stack.pop()]\n            width = i - stack[-1] - 1\n            max_area = max(max_area, height * width)\n        stack.append(i)\n\n    # 남아있는 인덱스들 처리 (끝까지 확장 가능한 경우)\n    n = len(heights)\n    while stack[-1] != -1:\n        height = heights[stack.pop()]\n        width = n - stack[-1] - 1\n        max_area = max(max_area, height * width)\n\n    return max_area\n\n\nif __name__ == \"__main__\":\n    # 기본 테스트들 (간단한 자기검증)\n    assert solution([]) == 0\n    assert solution([2]) == 2\n    assert solution([2, 4]) == 4  # max(2*2,4*1)=4\n    assert solution([2,1,5,6,2,3]) == 10  # 유명한 예시\n    assert solution([6,2,5,4,5,1,6]) == 12\n    assert solution([0,0,0]) == 0\n    print(\"All basic tests passed.\")\n```\n\n**테스트 가이드**\n- 대표 케이스: [2,1,5,6,2,3] -> 10 (중간 큰 직사각형)\n- 단일 원소: [7] -> 7\n- 오름차순/내림차순: [1,2,3,4,5], [5,4,3,2,1] (경계 처리 확인)\n- 빈 리스트 및 0이 포함된 경우: [], [0,0,1,0]\n\n**추가 개선**\n- 큰 입력(수백만 길이)에 대한 메모리/성능 스트레스 테스트 추가 및 벤치마크 자동화.\n- 입력이 스트림으로 주어질 때(전체 배열을 미리 알 수 없는 경우)를 위한 온라인 알고리즘/슬라이딩 윈도우 확장 연구.\n- C 확장 또는 Cython으로 성능을 더 끌어올리는 옵션(핫루프 최적화).\n- 타입 검사와 에러 처리를 추가해 잘못된 입력(음수 등)에 대한 견고성 향상.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "min_cost_path_grid", "engine": "api-single", "timestamp": "2025-11-15T11:21:46.252817+00:00", "elapsed_sec": 31.394, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n오른쪽/아래로만 이동할 때 각 칸 비용의 합이 최소가 되도록 하는 값을 행 단위 O(n) 추가 공간의 동적 계획법(rolling DP)으로 계산합니다.\n\n**문제 분석**\n- 입력은 m x n 격자 grid로, 각 칸에는 0 이상의 정수 비용이 있음.\n- 시작은 (0,0), 목표는 (m-1,n-1), 가능한 이동은 오른쪽 또는 아래로만 제한됨.\n- 시간복잡도 O(m·n), 추가 공간을 O(n)으로 줄이는 것이 목표(또는 명확성을 위해 O(m·n) 2D DP 사용 가능).\n- 빈 입력이나 비정형(행 길이 불일치) 입력에 대해 안정적으로 처리해야 함.\n\n**실행 계획**\n1. 입력 유효성 검사: 빈 grid는 0 반환, 각 행 길이가 동일한지 확인.\n2. 열 수 n을 기준으로 길이 n의 1차원 dp 배열을 선언하고 dp[j]는 현재 처리 중인 행까지의 (i,j)로의 최소 비용을 저장.\n3. 첫 행을 누적합으로 초기화한 뒤, 각 다음 행에 대해 dp[0]는 위에서 내려오는 경우만 가능하므로 누적하고, 나머지 열은 왼쪽(dp[j-1])과 위(dp[j]) 중 작은 값에 현재 칸 비용을 더해 갱신.\n4. 마지막 행 처리 후 dp[-1]이 답이므로 반환. 추가로 작은 자동 검증(무작위 테스트와 2D DP 비교)을 포함하여 구현을 스스로 체크.\n\n**핵심 코드**\n```python\nfrom typing import List\nimport random\nimport sys\n\ndef solution(grid: List[List[int]]) -> int:\n    \"\"\"\n    오른쪽 또는 아래로만 이동할 수 있는 격자에서 (0,0) -> (m-1,n-1)까지의\n    최소 비용 합을 반환한다.\n\n    - grid: m x n 격자(각 원소는 0 이상의 정수)\n    - 반환값: 최소 비용 합 (정수)\n    \"\"\"\n    # 기본 검증\n    if not grid:  # 빈 grid\n        return 0\n    m = len(grid)\n    n = len(grid[0]) if grid[0] is not None else 0\n    if n == 0:\n        return 0\n\n    # 모든 행이 같은 길이인지 확인\n    for r in grid:\n        if len(r) != n:\n            raise ValueError(\"모든 행의 길이는 같아야 합니다 (rectangular grid).\")\n\n    # dp[j] = 현재 처리 중인 행 i까지의 열 j에 도달하는 최소 비용\n    # 첫 행 초기화: 누적합\n    dp = [0] * n\n    dp[0] = grid[0][0]\n    for j in range(1, n):\n        dp[j] = dp[j-1] + grid[0][j]\n\n    # 다음 행들 처리\n    for i in range(1, m):\n        # 첫 열은 위에서 내려오는 것만 가능\n        dp[0] += grid[i][0]\n        for j in range(1, n):\n            # 위에서 오는 비용 dp[j], 왼쪽에서 오는 비용 dp[j-1]\n            dp[j] = grid[i][j] + min(dp[j], dp[j-1])\n\n    return dp[-1]\n\n\n# --- 간단한 자체 검증용 보조 함수들(스크립트로 실행 시) ---\ndef _solution_bruteforce(grid: List[List[int]]) -> int:\n    \"\"\"작은 입력에 대해 2D DP로 계산하는 보조 함수(검증용).\"\"\"\n    if not grid:\n        return 0\n    m, n = len(grid), len(grid[0])\n    dp2 = [[0]*n for _ in range(m)]\n    dp2[0][0] = grid[0][0]\n    for j in range(1, n):\n        dp2[0][j] = dp2[0][j-1] + grid[0][j]\n    for i in range(1, m):\n        dp2[i][0] = dp2[i-1][0] + grid[i][0]\n        for j in range(1, n):\n            dp2[i][j] = grid[i][j] + min(dp2[i-1][j], dp2[i][j-1])\n    return dp2[m-1][n-1]\n\n\nif __name__ == \"__main__\":\n    # 대표적 예제\n    examples = [\n        ([[5]], 5),\n        ([[1,2,3],[4,5,6]], 1+2+3+6),  # 경로: 오른쪽, 오른쪽, 아래\n        ([[1,3,1],[1,5,1],[4,2,1]], 7),  # 유명한 예제, 최소 합 7\n    ]\n    for g, expected in examples:\n        res = solution(g)\n        print(\"grid:\", g, \"->\", res, \"(expected\", expected, \")\")\n        assert res == expected\n\n    # 무작위 검증 (작은 크기만)\n    for _ in range(200):\n        m = random.randint(1, 6)\n        n = random.randint(1, 6)\n        grid = [[random.randint(0, 9) for _ in range(n)] for _ in range(m)]\n        a = solution(grid)\n        b = _solution_bruteforce(grid)\n        if a != b:\n            print(\"Mismatch found!\")\n            print(grid)\n            print(a, b)\n            sys.exit(1)\n    print(\"Random tests passed.\")\n```\n\n**테스트 가이드**\n- 1x1 그리드: [[5]] → 반환 5\n- 작은 정수 예제: [[1,3,1],[1,5,1],[4,2,1]] → 반환 7\n- 무작위 작은 격자(m,n <= 6)에 대해 브루트포스(또는 2D DP)와 비교 검증\n\n**추가 개선**\n- 경로 자체(칸 좌표 리스트)를 함께 복원하려면 부모 포인터(또는 2D prev 테이블)를 유지하거나 1차원 DP 사용 후 역추적 로직을 추가.\n- 입력이 매우 커서 메모리/병렬화가 필요하면 블록 단위 처리나 외부 메모리 알고리즘 적용, 혹은 GPU/벡터 연산을 고려.\n- 이동이 사방(상하좌우)으로 허용되는 일반 최소 경로 문제로 확장 시 음수가 없으면 Dijkstra(우선순위 큐), 음수가 있으면 Bellman-Ford 또는 SPFA 적용.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "job_scheduling_max_profit", "engine": "api-single", "timestamp": "2025-11-15T11:22:09.807330+00:00", "elapsed_sec": 23.537, "success": false, "error": null, "checker_output": "Traceback (most recent call last):\n  File \"/root/ap/benchmarks/algorithm_test/job_scheduling_max_profit.py\", line 45, in <module>\n    main()\n  File \"/root/ap/benchmarks/algorithm_test/job_scheduling_max_profit.py\", line 36, in main\n    raise AssertionError(\nAssertionError: starts=[1, 2, 3, 4], ends=[3, 5, 10, 6], profits=[20, 20, 100, 70], expected 150, got 120", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n작업들을 시작 시간으로 정렬한 뒤, 각 작업에 대해 다음 겹치지 않는 작업 인덱스를 이분 탐색으로 찾아 점화식(dp)으로 최댓값을 구합니다.\n\n**문제 분석**\n- 각 작업 i는 [starts[i], ends[i]) 구간을 차지하므로 end가 같아도 start가 동일하면 겹침 여부 주의.\n- 선택된 작업들 간에 구간이 겹치면 안 되고, 목표는 선택한 작업들의 profits 합을 최대로 하는 것.\n- 작업 수 n ≤ 100으로 이분 탐색 + DP(또는 메모이제이션) 방식이 충분히 빠름.\n\n**실행 계획**\n1. (정렬) 작업들을 튜플 (start, end, profit)로 묶어 start 기준으로 오름차순 정렬.\n2. 시작시간들만 따로 리스트화하여 bisect_left를 위한 준비를 한다.\n3. (이분 탐색) 각 작업 i에 대해 ends[i] 이상의 첫 번째 시작 인덱스 j = bisect_left(starts, ends_i)를 구한다 — 즉 i를 선택했을 때 다음으로 가능한 작업의 인덱스.\n4. (동적 계획법) 뒤에서부터 dp 배열을 채워 dp[i] = max(profit_i + dp[j], dp[i+1])로 상태 전이하여 dp[0]을 반환.\n5. 간단한 내부 테스트 케이스들을 main에서 실행해 구현 검증.\n\n**핵심 코드**\n```python\nfrom bisect import bisect_left\nfrom typing import List, Tuple\n\ndef solution(starts: List[int], ends: List[int], profits: List[int]) -> int:\n    \"\"\"\n    Weighted interval scheduling:\n    - jobs: (start, end, profit)\n    - sort by start, use bisect_left to find next non-overlapping job index\n    - iterative DP from the end: dp[i] = max(profit[i] + dp[next_idx], dp[i+1])\n    \"\"\"\n    n = len(starts)\n    if n == 0:\n        return 0\n\n    # Build and sort jobs by start time\n    jobs: List[Tuple[int, int, int]] = sorted(zip(starts, ends, profits), key=lambda x: (x[0], x[1]))\n    sorted_starts = [job[0] for job in jobs]\n    sorted_ends = [job[1] for job in jobs]\n    sorted_profits = [job[2] for job in jobs]\n\n    # dp[i] = max profit achievable starting from job i (i in [0..n-1])\n    dp = [0] * (n + 1)  # dp[n] = 0 base\n\n    # Fill dp from the back\n    for i in range(n - 1, -1, -1):\n        # find smallest index j such that sorted_starts[j] >= sorted_ends[i]\n        j = bisect_left(sorted_starts, sorted_ends[i], lo=i+1, hi=n)\n        take = sorted_profits[i] + dp[j]\n        skip = dp[i + 1]\n        dp[i] = take if take > skip else skip\n\n    return dp[0]\n\nif __name__ == \"__main__\":\n    # 간단한 자체 검증\n    tests = [\n        # non-overlapping all\n        (([1, 3, 6], [2, 5, 7], [50, 10, 40]), 100),  # all can be taken\n        # overlapping choices\n        (([1, 2, 3, 3], [3, 5, 4, 6], [50, 10, 40, 70]), 120),  # choose job0(50) + job3(70)\n        # same start times\n        (([1, 1, 2], [3, 2, 4], [20, 100, 50]), 150),  # choose job1 (1~2 profit100) + job2 (2~4 profit50)\n        # empty\n        (([], [], []), 0),\n    ]\n    for inp, expected in tests:\n        s, e, p = inp\n        got = solution(s, e, p)\n        print(f\"starts={s}, ends={e}, profits={p} => {got} (expected {expected})\")\n        assert got == expected, f\"Test failed: got {got}, expected {expected}\"\n    print(\"모든 테스트 통과.\")\n```\n\n**테스트 가이드**\n- 겹치지 않는 모든 작업들을 포함할 수 있는 경우 (모두 더해지는지 확인).\n- 겹치는 작업들 중 최댓값을 고르는 경우 (예: 큰 이익 하나 vs 여러 작은 이익 조합).\n- 동일 시작 또는 동일 종료 시간이 있는 케이스(동일 시작이면 서로 겹침으로 처리).\n- 빈 입력 (0 작업).\n\n**추가 개선**\n- 선택된 작업들의 인덱스를 복원(reconstruct)하도록 parent 배열을 추가하여 실제 스케줄을 반환하도록 확장.\n- n이 커지고 시간 범위가 매우 넓을 때는 세그먼트 트리나 좌표 압축 + DP로 성능/메모리 향상.\n- 병렬 실행 가능성이 있거나 추가 제약(예: 머신 수 제한)이 있는 경우 다중머신 스케줄링으로 일반화.\n- 단위 테스트 프레임워크(pytest)용 테스트 케이스들을 분리하여 자동화.\n\n<END-OF-CODE>", "code_block_present": true}
{"task_id": "regex_match_dot_star", "engine": "api-single", "timestamp": "2025-11-15T11:22:34.601679+00:00", "elapsed_sec": 24.777, "success": true, "error": null, "checker_output": "PASS", "headline": "한 줄 요약", "response_body": "### 한 줄 요약\n동적 계획법으로 패턴 p의 '.'와 '*' 연산자를 고려해 문자열 s 전체가 정확히 매칭되는지 판정합니다.\n\n**문제 분석**\n- 입력 패턴 p는 문자, '.'(임의의 한 문자), '*'(바로 앞 요소의 0개 이상 반복)를 포함할 수 있음.\n- 매칭은 문자열 전체가 패턴 전체와 정확히 일치해야 True 반환.\n- 시간 복잡도 목표는 O(len(s) * len(p)), 안정적인 메모리 사용 필요.\n- 패턴이 비정상적(예: 선행 '*' 등)인 경우는 문제에서 보통 허용하지 않으므로 기본 가정은 유효한 패턴.\n\n**실행 계획**\n1. s 길이 n, p 길이 m을 구하고 (n+1)x(m+1) 크기의 DP 테이블(dp)을 준비.\n2. dp[i][j]를 \"s[i:]가 p[j:]와 매칭되는가\"로 정의하고 기저(base) 상태 dp[n][m]=True로 설정.\n3. 후향식(문자열 끝에서부터)으로 모든 i, j에 대해 다음을 계산:\n   - first_match = i < n and (p[j] == s[i] or p[j] == '.')\n   - 만약 p[j+1]가 '*'이면 dp[i][j] = dp[i][j+2] (0번 반복) or (first_match and dp[i+1][j]) (1번 이상 반복)\n   - 그렇지 않으면 dp[i][j] = first_match and dp[i+1][j+1]\n4. dp[0][0] 반환. 추가로 간단한 유닛테스트를 포함하여 함수 동작 검증.\n\n**핵심 코드**\n```python\n# 전체 구현: solution 함수와 간단한 테스트 실행\nfrom typing import List\n\ndef solution(s: str, p: str) -> bool:\n    \"\"\"\n    Regular expression matching with '.' and '*'.\n    '.' matches any single character.\n    '*' matches zero or more of the preceding element.\n    The match must cover the entire input string.\n    \"\"\"\n    n, m = len(s), len(p)\n    # dp[i][j]: whether s[i:] matches p[j:]\n    dp: List[List[bool]] = [[False] * (m + 1) for _ in range(n + 1)]\n    dp[n][m] = True  # empty string matches empty pattern\n\n    # Fill dp from the end toward the beginning\n    for i in range(n, -1, -1):\n        for j in range(m - 1, -1, -1):\n            first_match = (i < n) and (p[j] == s[i] or p[j] == '.')\n            # If next char in pattern is '*', handle zero or more occurrences\n            if j + 1 < m and p[j + 1] == '*':\n                # Two choices:\n                # 1) treat \"x*\" as zero occurrence -> skip x*\n                # 2) if first_match, consume one char from s and stay at same pattern j\n                dp[i][j] = dp[i][j + 2] or (first_match and dp[i + 1][j])\n            else:\n                dp[i][j] = first_match and dp[i + 1][j + 1]\n\n    return dp[0][0]\n\n\nif __name__ == \"__main__\":\n    # 간단한 테스트 케이스\n    tests = [\n        (\"aa\", \"a\", False),\n        (\"aa\", \"a*\", True),\n        (\"ab\", \".*\", True),\n        (\"aab\", \"c*a*b\", True),\n        (\"mississippi\", \"mis*is*p*.\", False),\n        (\"\", \"a*\", True),        # 'a*' can match empty\n        (\"\", \"\", True),\n        (\"\", \".\", False),\n        (\"abc\", \"abc\", True),\n        (\"ab\", \".*c\", False),\n    ]\n\n    all_ok = True\n    for s, p, expected in tests:\n        result = solution(s, p)\n        print(f\"solution({s!r}, {p!r}) = {result} (expected {expected})\")\n        if result != expected:\n            all_ok = False\n\n    if all_ok:\n        print(\"All tests passed.\")\n    else:\n        print(\"Some tests failed.\")\n```\n\n**테스트 가이드**\n- 기본 매칭: s=\"aa\", p=\"a\" -> False; s=\"aa\", p=\"a*\" -> True\n- 와일드카드: s=\"ab\", p=\".*\" -> True\n- 복합 패턴: s=\"aab\", p=\"c*a*b\" -> True (c* -> 0, a* -> \"aa\", b -> \"b\")\n- 실패 사례: s=\"mississippi\", p=\"mis*is*p*.\" -> False\n\n**추가 개선**\n- 메모리 최적화: dp 테이블을 행 단위(1차원)로 축소하여 O(m) 공간으로 개선 가능.\n- 입력 검증: 선행 '*' 또는 연속 '*' 같은 비정상 패턴을 사전에 검사해 명확한 에러 처리 또는 규칙 적용.\n- 성능 확장: 매우 큰 패턴/문자열에 대해 NFA/DFA 변환을 사용하면 일부 케이스에서 더 빠른 처리 가능.\n- 테스트 확장: fuzzing 또는 property-based 테스트(예: Hypothesis)를 통해 경계 조건과 랜덤 케이스 검증을 강화.\n\n<END-OF-CODE>", "code_block_present": true}

{"id":"changelog_parser_structured","prompt":"Keep a Changelog 형식을 따르는 릴리스 노트를 파싱해 구조화된 데이터를 생성하세요.\n\n함수 시그니처\n```python\ndef solution(changelog: str) -> dict[str, object]:\n```\n요구사항\n- 입력 문자열에는 `## [버전] - YYYY-MM-DD` 또는 `## [Unreleased]` 헤더와 그 아래 `### Added / Fixed / Security ...` 섹션, 그리고 `- `로 시작하는 항목들이 포함됩니다.\n- 반환 객체는 다음 스키마를 따라야 합니다.\n  ```python\n  {\n      \"entries\": [\n          {\n              \"label\": str,          # 헤더의 버전 혹은 \"Unreleased\"\n              \"date\": str | None,    # 날짜가 없는 경우 None\n              \"sections\": {\n                  str: list[str]      # 섹션명 -> 항목 리스트 (원문 순서 보존)\n              }\n          },\n          ...\n      ],\n      \"latest_release\": {  # entries 중 Unreleased를 제외한 최신 버전 하나\n          \"label\": str,\n          \"date\": str,\n          \"sections\": dict[str, list[str]]\n      }\n  }\n  ```\n- `entries`는 changelog에 등장하는 순서를 유지해야 하며, 내용이 없는 섹션은 딕셔너리에 포함하지 않습니다.\n- 불릿 앞뒤 공백, 마크다운 강조(`*`, `` ` `` 등)는 제거하거나 그대로 두어도 되지만 항목 문자열 양 끝 공백은 제거합니다.\n- `latest_release`는 가장 최근 버전(날짜가 가장 위에 있는 첫 번째 릴리스이며 Unreleased 제외)을 가리켜야 하고, `entries`에 있는 동일한 구조체를 재사용하거나 값을 복사해도 됩니다.\n- 표준 라이브러리만 사용하세요.\n\n출력 형식\n- 요구사항을 만족하는 `solution` 구현을 하나의 파이썬 코드 블록으로 작성합니다.\n","language":"python","test":"benchmarks/swe_benchmark_test/changelog_parser.py"}
{"id":"service_health_dashboard","prompt":"서비스별/지역별 SLO 스냅샷을 취합해 실행 가능한 운영 대시보드를 생성하세요.\n\n함수 시그니처\n```python\ndef solution(snapshots: list[dict[str, object]], *, latency_budget: int = 140, error_budget: float = 1.0, deploy_recency: int = 180) -> dict[str, object]:\n```\n요구사항\n- snapshot 각 항목은 `service`, `region`, `latency_ms_p95`, `error_rate`(%) , `uptime`(0~1), `alerts`(문자열 리스트), `deploy_offset_min` 필드를 가진다고 가정합니다.\n- 반환 객체는 최소한 아래 키를 포함해야 합니다.\n  - `services`: 서비스명 -> 요약 딕셔너리. 각 요약은 `status`, `regions`, `action_items`를 포함합니다.\n    - `regions`는 지역 -> `{status, latency_ms_p95, error_rate, uptime, alerts}` 구조여야 합니다.\n    - 지역 상태 규칙: `alerts`에 `\"outage\"`가 포함되거나 `uptime < 0.92`면 `DOWN`, 그렇지 않고 `latency_ms_p95 > latency_budget` 또는 `error_rate > error_budget`이거나 알림이 존재/`deploy_offset_min > deploy_recency`면 `DEGRADED`, 그 외에는 `HEALTHY`.\n    - 서비스 상태는 각 지역 상태 중 최악(DOWN > DEGRADED > HEALTHY)을 따릅니다.\n    - `action_items`는 중복 없는 문자열 집합/리스트로, 포맷은 반드시 `\"<service>/<region>: <메시지>\"` 이어야 합니다. 메시지 규칙:\n      - 지연 초과: `latency p95 {latency}ms exceeds {latency_budget}ms budget`\n      - 에러율 초과: `error rate {rate:.2f}% exceeds {error_budget:.2f}% budget`\n      - 배포 지연: `deploy overdue by {deploy_offset_min} minutes`\n      - outage 감지: `outage declared via alerts`\n      - 그 외 일반 알림: `outstanding alerts <alert1,alert2>` (쉼표로 join)\n  - `total_regions`: 스냅샷 전체 개수\n  - `global_status`: 전체 서비스 상태 중 최악\n- 출력 딕셔너리에 추가 필드를 더해도 좋지만 위 필드와 문자열 규칙은 반드시 지켜야 합니다.\n- 입력 리스트나 내부 딕셔너리를 파괴적으로 수정하지 말고, 새 구조를 만들어 반환하세요.\n\n출력 형식\n- `solution` 전체 구현을 하나의 파이썬 코드 블록으로 작성합니다.\n","language":"python","test":"benchmarks/swe_benchmark_test/service_health_dashboard.py"}
{"id":"config_patch_engine","prompt":"운영 환경 설정을 정의한 딕셔너리에 패치 오퍼레이션 목록을 적용하는 엔진을 작성하세요.\n\n함수 시그니처\n```python\ndef solution(base_config: dict[str, object], operations: list[dict[str, object]]) -> dict[str, object]:\n```\n요구사항\n- `operations`는 `op` (`\"set\"`, `\"merge\"`, `\"remove\"`), `path`, `value`(remove 제외) 키를 가진 딕셔너리입니다.\n- `path`는 점(`.`)으로 구분된 키와 선택적으로 리스트 인덱스 표현(`[i]`)을 포함합니다. 예: `routers[0].headers.Cache-Control`.\n- `set`: 지정된 경로에 값을 할당합니다. 존재하지 않는 중간 딕셔너리는 자동으로 생성합니다. 리스트 인덱스가 현재 길이와 같으면 append, 작으면 덮어쓰기여야 하며, 그 외 범위는 오류를 내지 말고 `IndexError`를 발생시키세요.\n- `merge`: 경로가 가리키는 값과 `value`(dict)를 재귀적으로 병합합니다. 대상이 없으면 새 dict를 만들고, dict가 아닌 곳에 merge를 시도하면 `TypeError`를 발생시킵니다.\n- `remove`: 경로가 dict 키면 키를 삭제, 리스트 인덱스면 해당 요소를 제거하고 뒤 요소를 앞으로 당깁니다. 존재하지 않는 경로를 삭제하면 `KeyError` 또는 `IndexError`를 발생시켜야 합니다.\n- 함수는 원본 `base_config`를 변경하지 말고, 패치 결과를 담은 새 dict를 반환해야 합니다.\n\n출력 형식\n- 요구사항을 만족하는 `solution` 전체 구현을 파이썬 코드 블록 하나에 담아 작성합니다.\n","language":"python","test":"benchmarks/swe_benchmark_test/config_patch_engine.py"}

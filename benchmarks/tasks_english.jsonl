{"id":"two_sum_indices","prompt":"Given an integer array and a target sum, find two different indices whose values add up to target.\n\nFunction signature\n```python\ndef solution(nums: list[int], target: int) -> tuple[int, int]:\n```\nRequirements\n- Use 0-based indices and always return a tuple (i, j) with i < j.\n- If multiple answers exist, pick the lexicographically earliest pair (smallest i; if tied, smallest j).\n- If no answer exists, raise `ValueError`.\n- Input length is 2â€“2000, each value has absolute value up to 1e4.\n- Use only the standard library.\n\nOutput format\n- Implement the Python function returning the correct tuple, and put the full implementation inside the final code block.\n- You may briefly note a test strategy, but there must be exactly one code block.\n","language":"python","test":"benchmarks/algorithm_test/two_sum_indices.py"}
{"id":"run_length_compress","prompt":"Write a function that compresses a given string using Run-Length Encoding. The input contains only ASCII characters and its length is at most 10^4.\n\nFunction signature\n```python\ndef solution(text: str) -> str:\n```\nRequirements\n- For each run of identical characters, append <char><count> to the output.\n- Always include the count even when it is 1 (e.g., 'ab' -> 'a1b1').\n- Case-sensitive; encode any character (spaces, digits, symbols) as-is.\n- Return an empty string when the input is empty.\n- Do not use external libraries.\n\nOutput format\n- Provide a single Python code block containing the `solution` implementation.\n","language":"python","test":"benchmarks/algorithm_test/run_length_compress.py"}
{"id":"spiral_flatten","prompt":"Write a function that reads a matrix in spiral order and returns a 1D list.\n\nFunction signature\n```python\ndef solution(matrix: list[list[int]]) -> list[int]:\n```\nRequirements\n- `matrix` is at least 1x1 and at most 40x40 (square or rectangular).\n- Spiral order starts at (0, 0), goes right, and rotates clockwise when hitting a boundary.\n- Do not modify the input; return a new list.\n- Only standard Python features (e.g., list comprehensions) are allowed.\n\nOutput format\n- One Python code block containing the function and any helpers you need.\n","language":"python","test":"benchmarks/algorithm_test/spiral_flatten.py"}
{"id":"bugfix_quixbugs_depth_first_search","prompt":"Based on the QuixBugs `DEPTH_FIRST_SEARCH` report, implement a correct DFS for a directed graph. The original bug mishandled visit order and could loop on cycles.\n\nFunction signature\n```python\ndef solution(graph: dict[str, list[str]], start: str) -> list[str]:\n```\nRequirements\n- `graph` maps each node to its adjacency list (directed edges, order preserved). Missing keys mean nonexistent nodes.\n- DFS visits `start`, then explores neighbors depth-first in adjacency order, skipping already-visited nodes.\n- Return the visitation order as a list; do not mutate the input graph.\n- If `start` is absent, raise `ValueError`.\n- You may use recursion or an explicit stack; ensure termination with cycles.\n\nOutput format\n- A single Python code block with the full implementation; helper functions are allowed.\n","language":"python","test":"benchmarks/algorithm_test/bugfix_quixbugs_depth_first_search.py"}
{"id":"bugfix_swebench_django_slugify","prompt":"Reproduce the SWE-bench (Django #14662) `slugify` regression fix. Implement a function that converts a string to a URL slug. The original bug broke handling of repeated separators, non-ASCII characters, and the `allow_unicode` option.\n\nFunction signature\n```python\ndef solution(value: str, allow_unicode: bool = False) -> str:\n```\nRequirements\n- By default, lowercase the string and allow only letters, digits, and hyphens. Convert spaces/underscores to hyphens, collapse repeated hyphens, and trim hyphens at both ends.\n- When `allow_unicode` is False, run `unicodedata.normalize('NFKD', value)` and strip to ASCII only. When True, preserve Unicode letters (e.g., Hangul/Latin extensions) but still only allow alphanumerics, hyphens, spaces, and underscores before conversion.\n- If everything is stripped out, return an empty string.\n- Do not modify the input string; return a new one.\n\nOutput format\n- Using only the standard library, provide one Python code block with the `solution` implementation.\n","language":"python","test":"benchmarks/algorithm_test/bugfix_swebench_django_slugify.py"}
{"id":"sum_even_numbers","prompt":"Given an integer array, compute the sum of its even elements.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> int:\n```\nRequirements\n- `nums` length is between 0 and 1e5.\n- Sum only the even values and return the total.\n- If no even numbers exist, return 0.\n- Do not modify `nums`.\n\nOutput format\n- Provide one Python code block with the full implementation; only `solution` is needed for testing.\n","language":"python","test":"benchmarks/algorithm_test/sum_even_numbers.py"}
{"id":"count_vowels","prompt":"Count the number of vowels in an English string.\n\nFunction signature\n```python\ndef solution(text: str) -> int:\n```\nRequirements\n- Vowels are a, e, i, o, u; case-insensitive.\n- Ignore non-alphabetic characters; just count vowel letters.\n- String length is up to 1e5.\n\nOutput format\n- Provide one Python code block with the complete implementation.\n","language":"python","test":"benchmarks/algorithm_test/count_vowels.py"}
{"id":"reverse_words","prompt":"Write a function that reverses the order of words in a sentence, splitting by spaces.\n\nFunction signature\n```python\ndef solution(text: str) -> str:\n```\nRequirements\n- A word is any sequence of one or more non-space characters.\n- Ignore the number of spaces between words; in the result, join words with a single space.\n- Strip leading/trailing spaces.\n- Example: '  hello   world  ' -> 'world hello'.\n\nOutput format\n- Provide a single Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/reverse_words.py"}
{"id":"unique_elements_count","prompt":"Count the number of distinct elements in an integer list.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> int:\n```\nRequirements\n- `nums` length is between 0 and 1e5.\n- Each value has absolute value up to 1e9.\n- Return the count of unique values.\n\nOutput format\n- Provide one code block containing the `solution` implementation.\n","language":"python","test":"benchmarks/algorithm_test/unique_elements_count.py"}
{"id":"prefix_sums","prompt":"Compute the prefix sum array for a list of integers.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> list[int]:\n```\nRequirements\n- The i-th value of the return list is the sum of nums[0] through nums[i].\n- If `nums` is empty, return an empty list.\n- Do not modify `nums`.\n\nOutput format\n- Provide one Python code block with the complete implementation.\n","language":"python","test":"benchmarks/algorithm_test/prefix_sums.py"}
{"id":"merge_sorted_lists","prompt":"Merge two sorted integer lists into one sorted list.\n\nFunction signature\n```python\ndef solution(a: list[int], b: list[int]) -> list[int]:\n```\nRequirements\n- `a` and `b` are individually sorted in non-decreasing order.\n- Return a new sorted list containing all elements of `a` and `b`.\n- Do not modify the input lists.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/merge_sorted_lists.py"}
{"id":"is_anagram","prompt":"Determine whether two strings are anagrams.\n\nFunction signature\n```python\ndef solution(s: str, t: str) -> bool:\n```\nRequirements\n- Case-insensitive comparison.\n- Ignore all whitespace characters.\n- Compare the multisets of remaining characters; return True if they match, else False.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/is_anagram.py"}
{"id":"balanced_parentheses","prompt":"Check whether the parentheses in a string are balanced.\n\nFunction signature\n```python\ndef solution(s: str) -> bool:\n```\nRequirements\n- `s` may contain any characters; parentheses are (), [], {}.\n- Ignore non-parenthesis characters.\n- Return True if parentheses are properly matched and nested; otherwise False.\n- An empty string counts as True.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/balanced_parentheses.py"}
{"id":"interval_merge","prompt":"Merge overlapping intervals.\n\nFunction signature\n```python\ndef solution(intervals: list[tuple[int, int]]) -> list[tuple[int, int]]:\n```\nRequirements\n- Each interval is a tuple (start, end) with start <= end.\n- Treat them as closed intervals; merge if they overlap or touch.\n- Return a list sorted by start.\n- Do not modify the input list.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/interval_merge.py"}
{"id":"matrix_transpose","prompt":"Compute the transpose of a given matrix.\n\nFunction signature\n```python\ndef solution(matrix: list[list[int]]) -> list[list[int]]:\n```\nRequirements\n- `matrix` is a non-empty rectangular grid.\n- Return a new list with the transposed matrix.\n- Do not mutate the original matrix.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/matrix_transpose.py"}
{"id":"subarray_sum_equals_k_count","prompt":"Count the number of contiguous subarrays whose sum equals k.\n\nFunction signature\n```python\ndef solution(nums: list[int], k: int) -> int:\n```\nRequirements\n- `nums` length is 0 to 1e5.\n- Each `nums[i]` has absolute value up to 1e4.\n- Return the count of subarrays summing to k.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/subarray_sum_equals_k_count.py"}
{"id":"longest_common_prefix","prompt":"Find the longest common prefix among a list of strings.\n\nFunction signature\n```python\ndef solution(strs: list[str]) -> str:\n```\nRequirements\n- If `strs` is empty, return an empty string.\n- Comparison is case-sensitive.\n- Return the longest prefix shared by all strings.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/longest_common_prefix.py"}
{"id":"rotate_list_right","prompt":"Rotate a list to the right by k steps.\n\nFunction signature\n```python\ndef solution(nums: list[int], k: int) -> list[int]:\n```\nRequirements\n- `nums` length is 0 to 1e5.\n- `k` is an integer between 0 and 1e9.\n- Return a new list rotated right by k.\n- Do not modify `nums`.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/rotate_list_right.py"}
{"id":"longest_unique_substring","prompt":"Return the length of the longest substring without repeated characters.\n\nFunction signature\n```python\ndef solution(s: str) -> int:\n```\nRequirements\n- A substring is a contiguous range within the string.\n- Among substrings where all characters are distinct, return the maximum length.\n- `s` length is at least 0 and may be assumed ASCII.\n\nExamples\n- s = \"abcabcbb\" -> max length 3 (e.g., \"abc\" or \"bca\")\n- s = \"bbbbb\" -> max length 1\n- s = \"pwwkew\" -> max length 3 (\"wke\")\n- s = \"\" -> 0\n\nOutput format\n- Implement an O(n) sliding window (or similar) solution and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/longest_unique_substring.py"}
{"id":"num_islands","prompt":"Count the number of islands in a grid of '0' and '1'.\n\nFunction signature\n```python\ndef solution(grid: list[list[str]]) -> int:\n```\nRequirements\n- `grid` is an m x n 2D list containing only characters '0' and '1'.\n- '1' represents land; '0' represents water.\n- Adjacent land cells connected up/down/left/right form one island.\n- Return the total number of islands.\n\nOutput format\n- Use DFS, BFS, or any method; provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/num_islands.py"}
{"id":"longest_increasing_subarray","prompt":"Find the length of the longest strictly increasing contiguous subarray.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> int:\n```\nRequirements\n- If `nums` is empty, return 0.\n- The subarray must be strictly increasing (each element greater than the previous).\n- Length 1 counts as valid.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/longest_increasing_subarray.py"}
{"id":"edit_distance","prompt":"Compute the Levenshtein edit distance between two strings.\n\nFunction signature\n```python\ndef solution(s: str, t: str) -> int:\n```\nRequirements\n- Allowed operations: insertion, deletion, substitution.\n- Each operation costs 1.\n- Return the minimum operations to turn `s` into `t`.\n\nOutput format\n- Use dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/edit_distance.py"}
{"id":"word_break","prompt":"Determine whether string s can be segmented entirely into words from the given dictionary.\n\nFunction signature\n```python\ndef solution(s: str, word_dict: list[str]) -> bool:\n```\nRequirements\n- Return True if concatenating dictionary words (each usable multiple times) can exactly form `s` without spaces.\n- Otherwise, return False.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/word_break.py"}
{"id":"max_subarray_sum","prompt":"Find the maximum sum of any contiguous subarray in an integer array.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> int:\n```\nRequirements\n- `nums` length is at least 1.\n- All numbers may be negative.\n- Return the maximum subarray sum.\n\nOutput format\n- Implement using Kadane's algorithm or any approach; provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/max_subarray_sum.py"}
{"id":"shortest_path_unweighted","prompt":"In an unweighted directed graph, compute the shortest distance from a start node to every reachable node.\n\nFunction signature\n```python\ndef solution(graph: dict[str, list[str]], start: str) -> dict[str, int]:\n```\nRequirements\n- `graph` is an adjacency-list dictionary containing every existing node as a key.\n- Distance is the minimum number of edges from `start` to each node.\n- Exclude nodes that are unreachable from `start` from the result.\n- If `start` is not in the graph, raise `ValueError`.\n\nOutput format\n- Use BFS (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/shortest_path_unweighted.py"}
{"id":"meeting_rooms_min","prompt":"Given meeting time intervals, find the minimum number of rooms required to host all meetings.\n\nFunction signature\n```python\ndef solution(intervals: list[tuple[int, int]]) -> int:\n```\nRequirements\n- Each meeting is a tuple (start, end) with start < end.\n- A room cannot host overlapping meetings.\n- Return the minimum number of rooms needed to schedule all meetings.\n\nOutput format\n- Provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/meeting_rooms_min.py"}
{"id":"topological_sort","prompt":"Return a topological ordering of a directed acyclic graph (DAG).\n\nFunction signature\n```python\ndef solution(graph: dict[str, list[str]]) -> list[str]:\n```\nRequirements\n- `graph` is a dictionary mapping each node to its adjacency list.\n- The graph is assumed to be a DAG.\n- Return the lexicographically smallest valid topological order.\n\nOutput format\n- Use Kahn's algorithm or DFS; provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/topological_sort.py"}
{"id":"knapsack_01_max_value","prompt":"Solve the 0-1 knapsack problem for maximum value.\n\nFunction signature\n```python\ndef solution(weights: list[int], values: list[int], capacity: int) -> int:\n```\nRequirements\n- `weights[i]` and `values[i]` describe item i.\n- Each item can be taken 0 or 1 time.\n- Maximize total value without exceeding `capacity`.\n- Assume n up to about 30 and capacity up to about 1000.\n\nOutput format\n- Use dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/knapsack_01_max_value.py"}
{"id":"coin_change_min_coins","prompt":"Given coin denominations, find the minimum number of coins needed to make a target amount.\n\nFunction signature\n```python\ndef solution(coins: list[int], amount: int) -> int:\n```\nRequirements\n- Each coin can be used unlimited times.\n- If the amount cannot be formed exactly, return -1.\n- `amount` is between 0 and 1e4 inclusive.\n\nOutput format\n- Use dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/coin_change_min_coins.py"}
{"id":"longest_increasing_subsequence_length","prompt":"Compute the length of the Longest Increasing Subsequence (LIS) of a sequence.\n\nFunction signature\n```python\ndef solution(nums: list[int]) -> int:\n```\nRequirements\n- An increasing subsequence uses increasing indices with strictly increasing values.\n- Assume `nums` length is up to 2000.\n- Return the LIS length.\n\nOutput format\n- Implement in O(n^2) or O(n log n); provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/longest_increasing_subsequence_length.py"}
{"id":"min_window_substring","prompt":"Given strings s and t, find the minimum window substring in s that contains all characters of t.\n\nFunction signature\n```python\ndef solution(s: str, t: str) -> str:\n```\nRequirements\n- Must satisfy the frequency of each character in t.\n- If multiple windows satisfy the condition, return the shortest; if lengths tie, pick the one with the smallest start index.\n- If no such window exists, return an empty string.\n\nOutput format\n- Use a two-pointer sliding window (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/min_window_substring.py"}
{"id":"max_rectangle_in_histogram","prompt":"Compute the area of the largest rectangle in a histogram.\n\nFunction signature\n```python\ndef solution(heights: list[int]) -> int:\n```\nRequirements\n- `heights[i]` is the height of bar i.\n- Consider rectangles formed by one or more adjacent bars; return the maximum area.\n\nOutput format\n- Use a stack-based O(n) algorithm (or other) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/max_rectangle_in_histogram.py"}
{"id":"min_cost_path_grid","prompt":"Given a grid of costs, find the minimum cost path from the top-left to the bottom-right.\n\nFunction signature\n```python\ndef solution(grid: list[list[int]]) -> int:\n```\nRequirements\n- `grid[i][j]` is a nonnegative integer cost.\n- Start at (0, 0) and move only right or down to reach (m-1, n-1).\n- Return the minimal possible sum of visited cell costs.\n\nOutput format\n- Use dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/min_cost_path_grid.py"}
{"id":"job_scheduling_max_profit","prompt":"Given start times, end times, and profits of jobs, select a subset with maximum total profit.\n\nFunction signature\n```python\ndef solution(starts: list[int], ends: list[int], profits: list[int]) -> int:\n```\nRequirements\n- Job i runs in interval [starts[i], ends[i]); overlapping jobs cannot both be chosen.\n- Maximize the sum of profits for selected jobs.\n- Number of jobs is at most 100.\n\nOutput format\n- Use sorting plus binary search with dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/job_scheduling_max_profit.py"}
{"id":"regex_match_dot_star","prompt":"Implement pattern matching similar to regular expressions.\n\nFunction signature\n```python\ndef solution(s: str, p: str) -> bool:\n```\nRequirements\n- Pattern `p` may contain normal characters, dot '.', and star '*'.\n- '.' matches any single character.\n- '*' means the preceding character (or '.') repeats zero or more times.\n- Return True if the entire pattern matches the entire string; otherwise False.\n\nOutput format\n- Use dynamic programming (or similar) and provide one Python code block with the full implementation.\n","language":"python","test":"benchmarks/algorithm_test/regex_match_dot_star.py"}
